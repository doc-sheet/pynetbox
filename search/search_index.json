{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"PyNetBox Documentation","text":""},{"location":"#tldr","title":"TL;DR","text":"<p>Instantiate the <code>Api</code> class. Use the methods available on <code>Endpoint</code> to return <code>Record</code> objects.</p>"},{"location":"#api-reference","title":"API Reference","text":""},{"location":"#pynetbox.core.api.Api","title":"<code> pynetbox.core.api.Api        </code>","text":"<p>The API object is the point of entry to pynetbox.</p> <p>After instantiating the Api() with the appropriate named arguments you can specify which app and endpoint you wish to interact with.</p> <p>Valid attributes currently are:</p> <ul> <li>circuits</li> <li>core (NetBox 3.5+)</li> <li>dcim</li> <li>extras</li> <li>ipam</li> <li>tenancy</li> <li>users</li> <li>virtualization</li> <li>vpn (NetBox 3.7+)</li> <li>wireless</li> </ul> <p>Calling any of these attributes will return an <code>App</code> object which exposes endpoints as attributes.</p>"},{"location":"#pynetbox.core.api.Api--additional-attributes","title":"Additional Attributes","text":"<ul> <li>http_session(requests.Session): Override the default session with your own. This is used to control   a number of HTTP behaviors such as SSL verification, custom headers,   retires, and timeouts.   See custom sessions for more info.</li> </ul>"},{"location":"#pynetbox.core.api.Api--parameters","title":"Parameters","text":"<ul> <li>url (str): The base URL to the instance of NetBox you wish to connect to.</li> <li>token (str): Your NetBox token.</li> <li>threading (bool, optional): Set to True to use threading in <code>.all()</code> and <code>.filter()</code> requests.</li> </ul>"},{"location":"#pynetbox.core.api.Api--raises","title":"Raises","text":"<ul> <li>AttributeError: If app doesn't exist.</li> </ul>"},{"location":"#pynetbox.core.api.Api--examples","title":"Examples","text":"<pre><code>import pynetbox\nnb = pynetbox.api(\n    'http://localhost:8000',\n    token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n)\nlist(nb.dcim.devices.all())\n# [test1-leaf1, test1-leaf2, test1-leaf3]\n</code></pre> Source code in <code>pynetbox/core/api.py</code> <pre><code>class Api:\n    \"\"\"The API object is the point of entry to pynetbox.\n\n    After instantiating the Api() with the appropriate named arguments\n    you can specify which app and endpoint you wish to interact with.\n\n    Valid attributes currently are:\n\n    * circuits\n    * core (NetBox 3.5+)\n    * dcim\n    * extras\n    * ipam\n    * tenancy\n    * users\n    * virtualization\n    * vpn (NetBox 3.7+)\n    * wireless\n\n    Calling any of these attributes will return an `App` object which exposes endpoints as attributes.\n\n    ## Additional Attributes\n\n    * **http_session(requests.Session)**: Override the default session with your own. This is used to control\n      a number of HTTP behaviors such as SSL verification, custom headers,\n      retires, and timeouts.\n      See [custom sessions](advanced.md#custom-sessions) for more info.\n\n    ## Parameters\n\n    * **url** (str): The base URL to the instance of NetBox you wish to connect to.\n    * **token** (str): Your NetBox token.\n    * **threading** (bool, optional): Set to True to use threading in `.all()` and `.filter()` requests.\n\n    ## Raises\n\n    * **AttributeError**: If app doesn't exist.\n\n    ## Examples\n\n    ```python\n    import pynetbox\n    nb = pynetbox.api(\n        'http://localhost:8000',\n        token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n    )\n    list(nb.dcim.devices.all())\n    # [test1-leaf1, test1-leaf2, test1-leaf3]\n    ```\n    \"\"\"\n\n    def __init__(\n        self,\n        url,\n        token=None,\n        threading=False,\n        strict_filters=False,\n    ):\n        \"\"\"Initialize the API client.\n\n        Args:\n            url (str): The base URL to the instance of NetBox you wish to connect to.\n            token (str, optional): Your NetBox API token. If not provided, authentication will be required for each request.\n            threading (bool, optional): Set to True to use threading in `.all()` and `.filter()` requests, defaults to False.\n            strict_filters (bool, optional): Set to True to check GET call filters against OpenAPI specifications (intentionally not done in NetBox API), defaults to False.\n        \"\"\"\n        base_url = \"{}/api\".format(url if url[-1] != \"/\" else url[:-1])\n        self.token = token\n        self.base_url = base_url\n        self.http_session = requests.Session()\n        self.threading = threading\n        self.strict_filters = strict_filters\n\n        # Initialize NetBox apps\n        self.circuits = App(self, \"circuits\")\n        self.core = App(self, \"core\")\n        self.dcim = App(self, \"dcim\")\n        self.extras = App(self, \"extras\")\n        self.ipam = App(self, \"ipam\")\n        self.tenancy = App(self, \"tenancy\")\n        self.users = App(self, \"users\")\n        self.virtualization = App(self, \"virtualization\")\n        self.vpn = App(self, \"vpn\")\n        self.wireless = App(self, \"wireless\")\n        self.plugins = PluginsApp(self)\n\n    @property\n    def version(self):\n        \"\"\"Gets the API version of NetBox.\n\n        Can be used to check the NetBox API version if there are\n        version-dependent features or syntaxes in the API.\n\n        ## Returns\n        Version number as a string.\n\n        ## Example\n\n        ```python\n        import pynetbox\n        nb = pynetbox.api(\n            'http://localhost:8000',\n            token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n        )\n        nb.version\n        # '3.1'\n        ```\n        \"\"\"\n        version = Request(\n            base=self.base_url,\n            token=self.token,\n            http_session=self.http_session,\n        ).get_version()\n        return version\n\n    def openapi(self):\n        \"\"\"Returns the OpenAPI spec.\n\n        Quick helper function to pull down the entire OpenAPI spec.\n        It is stored in memory to avoid repeated calls on NetBox API.\n\n        ## Returns\n        dict: The OpenAPI specification as a dictionary.\n\n        ## Example\n\n        ```python\n        import pynetbox\n        nb = pynetbox.api(\n            'http://localhost:8000',\n            token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n        )\n        nb.openapi()\n        # {...}\n        ```\n        \"\"\"\n        if not (openapi := getattr(self, \"_openapi\", None)):\n            openapi = self._openapi = Request(\n                base=self.base_url,\n                http_session=self.http_session,\n            ).get_openapi()\n\n        return openapi\n\n    def status(self):\n        \"\"\"Gets the status information from NetBox.\n\n        ## Returns\n        Dictionary containing NetBox status information.\n\n        ## Raises\n        `RequestError`: If the request is not successful.\n\n        ## Example\n\n        ```python\n        from pprint import pprint\n        pprint(nb.status())\n        {\n            'django-version': '3.1.3',\n            'installed-apps': {\n                'cacheops': '5.0.1',\n                'debug_toolbar': '3.1.1',\n                'django_filters': '2.4.0',\n                'django_prometheus': '2.1.0',\n                'django_rq': '2.4.0',\n                'django_tables2': '2.3.3',\n                'drf_yasg': '1.20.0',\n                'mptt': '0.11.0',\n                'rest_framework': '3.12.2',\n                'taggit': '1.3.0',\n                'timezone_field': '4.0'\n            },\n            'netbox-version': '2.10.2',\n            'plugins': {},\n            'python-version': '3.7.3',\n            'rq-workers-running': 1\n        }\n        ```\n        \"\"\"\n        status = Request(\n            base=self.base_url,\n            token=self.token,\n            http_session=self.http_session,\n        ).get_status()\n        return status\n\n    def create_token(self, username, password):\n        \"\"\"Creates an API token using a valid NetBox username and password.\n        Saves the created token automatically in the API object.\n\n        ## Parameters\n        * **username** (str): NetBox username\n        * **password** (str): NetBox password\n\n        ## Returns\n        `Record`: The token as a Record object.\n\n        ## Raises\n        `RequestError`: If the request is not successful.\n\n        ## Example\n\n        ```python\n        import pynetbox\n        nb = pynetbox.api(\"https://netbox-server\")\n        token = nb.create_token(\"admin\", \"netboxpassword\")\n        nb.token\n        # '96d02e13e3f1fdcd8b4c089094c0191dcb045bef'\n\n        from pprint import pprint\n        pprint(dict(token))\n        {\n            'created': '2021-11-27T11:26:49.360185+02:00',\n            'description': '',\n            'display': '045bef (admin)',\n            'expires': None,\n            'id': 2,\n            'key': '96d02e13e3f1fdcd8b4c089094c0191dcb045bef',\n            'url': 'https://netbox-server/api/users/tokens/2/',\n            'user': {\n                'display': 'admin',\n                'id': 1,\n                'url': 'https://netbox-server/api/users/users/1/',\n                'username': 'admin'\n            },\n            'write_enabled': True\n        }\n        ```\n        \"\"\"\n        resp = Request(\n            base=\"{}/users/tokens/provision/\".format(self.base_url),\n            http_session=self.http_session,\n        ).post(data={\"username\": username, \"password\": password})\n        # Save the newly created API token, otherwise populating the Record\n        # object details will fail\n        self.token = resp[\"key\"]\n        return Record(resp, self, None)\n\n    @contextlib.contextmanager\n    def activate_branch(self, branch):\n        \"\"\"Context manager to activate the branch by setting the schema ID in the headers.\n\n        **Note**: The NetBox branching plugin must be installed and enabled in your NetBox instance for this functionality to work.\n\n        ## Parameters\n        * **branch** (Record): The NetBox branch to activate\n\n        ## Raises\n        `ValueError`: If the branch is not a valid NetBox branch.\n\n        ## Example\n\n        ```python\n        import pynetbox\n        nb = pynetbox.api(\"https://netbox-server\")\n        branch = nb.plugins.branching.branches.create(name=\"testbranch\")\n        with nb.activate_branch(branch):\n            sites = nb.dcim.sites.all()\n            # All operations within this block will use the branch's schema\n        ```\n        \"\"\"\n        if not isinstance(branch, Record) or not \"schema_id\" in dict(branch):\n            raise ValueError(\n                f\"The specified branch is not a valid NetBox branch: {branch}.\"\n            )\n\n        self.http_session.headers[\"X-NetBox-Branch\"] = branch.schema_id\n\n        try:\n            yield\n        finally:\n            self.http_session.headers.pop(\"X-NetBox-Branch\", None)\n</code></pre>"},{"location":"#pynetbox.core.api.Api.version","title":"<code>version</code>  <code>property</code> <code>readonly</code>","text":"<p>Gets the API version of NetBox.</p> <p>Can be used to check the NetBox API version if there are version-dependent features or syntaxes in the API.</p>"},{"location":"#pynetbox.core.api.Api.version--returns","title":"Returns","text":"<p>Version number as a string.</p>"},{"location":"#pynetbox.core.api.Api.version--example","title":"Example","text":"<pre><code>import pynetbox\nnb = pynetbox.api(\n    'http://localhost:8000',\n    token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n)\nnb.version\n# '3.1'\n</code></pre>"},{"location":"#pynetbox.core.api.Api.__init__","title":"<code>__init__(self, url, token=None, threading=False, strict_filters=False)</code>  <code>special</code>","text":"<p>Initialize the API client.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The base URL to the instance of NetBox you wish to connect to.</p> required <code>token</code> <code>str</code> <p>Your NetBox API token. If not provided, authentication will be required for each request.</p> <code>None</code> <code>threading</code> <code>bool</code> <p>Set to True to use threading in <code>.all()</code> and <code>.filter()</code> requests, defaults to False.</p> <code>False</code> <code>strict_filters</code> <code>bool</code> <p>Set to True to check GET call filters against OpenAPI specifications (intentionally not done in NetBox API), defaults to False.</p> <code>False</code> Source code in <code>pynetbox/core/api.py</code> <pre><code>def __init__(\n    self,\n    url,\n    token=None,\n    threading=False,\n    strict_filters=False,\n):\n    \"\"\"Initialize the API client.\n\n    Args:\n        url (str): The base URL to the instance of NetBox you wish to connect to.\n        token (str, optional): Your NetBox API token. If not provided, authentication will be required for each request.\n        threading (bool, optional): Set to True to use threading in `.all()` and `.filter()` requests, defaults to False.\n        strict_filters (bool, optional): Set to True to check GET call filters against OpenAPI specifications (intentionally not done in NetBox API), defaults to False.\n    \"\"\"\n    base_url = \"{}/api\".format(url if url[-1] != \"/\" else url[:-1])\n    self.token = token\n    self.base_url = base_url\n    self.http_session = requests.Session()\n    self.threading = threading\n    self.strict_filters = strict_filters\n\n    # Initialize NetBox apps\n    self.circuits = App(self, \"circuits\")\n    self.core = App(self, \"core\")\n    self.dcim = App(self, \"dcim\")\n    self.extras = App(self, \"extras\")\n    self.ipam = App(self, \"ipam\")\n    self.tenancy = App(self, \"tenancy\")\n    self.users = App(self, \"users\")\n    self.virtualization = App(self, \"virtualization\")\n    self.vpn = App(self, \"vpn\")\n    self.wireless = App(self, \"wireless\")\n    self.plugins = PluginsApp(self)\n</code></pre>"},{"location":"#pynetbox.core.api.Api.activate_branch","title":"<code>activate_branch(self, branch)</code>","text":"<p>Context manager to activate the branch by setting the schema ID in the headers.</p> <p>Note: The NetBox branching plugin must be installed and enabled in your NetBox instance for this functionality to work.</p>"},{"location":"#pynetbox.core.api.Api.activate_branch--parameters","title":"Parameters","text":"<ul> <li>branch (Record): The NetBox branch to activate</li> </ul>"},{"location":"#pynetbox.core.api.Api.activate_branch--raises","title":"Raises","text":"<p><code>ValueError</code>: If the branch is not a valid NetBox branch.</p>"},{"location":"#pynetbox.core.api.Api.activate_branch--example","title":"Example","text":"<pre><code>import pynetbox\nnb = pynetbox.api(\"https://netbox-server\")\nbranch = nb.plugins.branching.branches.create(name=\"testbranch\")\nwith nb.activate_branch(branch):\n    sites = nb.dcim.sites.all()\n    # All operations within this block will use the branch's schema\n</code></pre> Source code in <code>pynetbox/core/api.py</code> <pre><code>@contextlib.contextmanager\ndef activate_branch(self, branch):\n    \"\"\"Context manager to activate the branch by setting the schema ID in the headers.\n\n    **Note**: The NetBox branching plugin must be installed and enabled in your NetBox instance for this functionality to work.\n\n    ## Parameters\n    * **branch** (Record): The NetBox branch to activate\n\n    ## Raises\n    `ValueError`: If the branch is not a valid NetBox branch.\n\n    ## Example\n\n    ```python\n    import pynetbox\n    nb = pynetbox.api(\"https://netbox-server\")\n    branch = nb.plugins.branching.branches.create(name=\"testbranch\")\n    with nb.activate_branch(branch):\n        sites = nb.dcim.sites.all()\n        # All operations within this block will use the branch's schema\n    ```\n    \"\"\"\n    if not isinstance(branch, Record) or not \"schema_id\" in dict(branch):\n        raise ValueError(\n            f\"The specified branch is not a valid NetBox branch: {branch}.\"\n        )\n\n    self.http_session.headers[\"X-NetBox-Branch\"] = branch.schema_id\n\n    try:\n        yield\n    finally:\n        self.http_session.headers.pop(\"X-NetBox-Branch\", None)\n</code></pre>"},{"location":"#pynetbox.core.api.Api.create_token","title":"<code>create_token(self, username, password)</code>","text":"<p>Creates an API token using a valid NetBox username and password. Saves the created token automatically in the API object.</p>"},{"location":"#pynetbox.core.api.Api.create_token--parameters","title":"Parameters","text":"<ul> <li>username (str): NetBox username</li> <li>password (str): NetBox password</li> </ul>"},{"location":"#pynetbox.core.api.Api.create_token--returns","title":"Returns","text":"<p><code>Record</code>: The token as a Record object.</p>"},{"location":"#pynetbox.core.api.Api.create_token--raises","title":"Raises","text":"<p><code>RequestError</code>: If the request is not successful.</p>"},{"location":"#pynetbox.core.api.Api.create_token--example","title":"Example","text":"<pre><code>import pynetbox\nnb = pynetbox.api(\"https://netbox-server\")\ntoken = nb.create_token(\"admin\", \"netboxpassword\")\nnb.token\n# '96d02e13e3f1fdcd8b4c089094c0191dcb045bef'\n\nfrom pprint import pprint\npprint(dict(token))\n{\n    'created': '2021-11-27T11:26:49.360185+02:00',\n    'description': '',\n    'display': '045bef (admin)',\n    'expires': None,\n    'id': 2,\n    'key': '96d02e13e3f1fdcd8b4c089094c0191dcb045bef',\n    'url': 'https://netbox-server/api/users/tokens/2/',\n    'user': {\n        'display': 'admin',\n        'id': 1,\n        'url': 'https://netbox-server/api/users/users/1/',\n        'username': 'admin'\n    },\n    'write_enabled': True\n}\n</code></pre> Source code in <code>pynetbox/core/api.py</code> <pre><code>def create_token(self, username, password):\n    \"\"\"Creates an API token using a valid NetBox username and password.\n    Saves the created token automatically in the API object.\n\n    ## Parameters\n    * **username** (str): NetBox username\n    * **password** (str): NetBox password\n\n    ## Returns\n    `Record`: The token as a Record object.\n\n    ## Raises\n    `RequestError`: If the request is not successful.\n\n    ## Example\n\n    ```python\n    import pynetbox\n    nb = pynetbox.api(\"https://netbox-server\")\n    token = nb.create_token(\"admin\", \"netboxpassword\")\n    nb.token\n    # '96d02e13e3f1fdcd8b4c089094c0191dcb045bef'\n\n    from pprint import pprint\n    pprint(dict(token))\n    {\n        'created': '2021-11-27T11:26:49.360185+02:00',\n        'description': '',\n        'display': '045bef (admin)',\n        'expires': None,\n        'id': 2,\n        'key': '96d02e13e3f1fdcd8b4c089094c0191dcb045bef',\n        'url': 'https://netbox-server/api/users/tokens/2/',\n        'user': {\n            'display': 'admin',\n            'id': 1,\n            'url': 'https://netbox-server/api/users/users/1/',\n            'username': 'admin'\n        },\n        'write_enabled': True\n    }\n    ```\n    \"\"\"\n    resp = Request(\n        base=\"{}/users/tokens/provision/\".format(self.base_url),\n        http_session=self.http_session,\n    ).post(data={\"username\": username, \"password\": password})\n    # Save the newly created API token, otherwise populating the Record\n    # object details will fail\n    self.token = resp[\"key\"]\n    return Record(resp, self, None)\n</code></pre>"},{"location":"#pynetbox.core.api.Api.openapi","title":"<code>openapi(self)</code>","text":"<p>Returns the OpenAPI spec.</p> <p>Quick helper function to pull down the entire OpenAPI spec. It is stored in memory to avoid repeated calls on NetBox API.</p>"},{"location":"#pynetbox.core.api.Api.openapi--returns","title":"Returns","text":"<p>dict: The OpenAPI specification as a dictionary.</p>"},{"location":"#pynetbox.core.api.Api.openapi--example","title":"Example","text":"<pre><code>import pynetbox\nnb = pynetbox.api(\n    'http://localhost:8000',\n    token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n)\nnb.openapi()\n# {...}\n</code></pre> Source code in <code>pynetbox/core/api.py</code> <pre><code>def openapi(self):\n    \"\"\"Returns the OpenAPI spec.\n\n    Quick helper function to pull down the entire OpenAPI spec.\n    It is stored in memory to avoid repeated calls on NetBox API.\n\n    ## Returns\n    dict: The OpenAPI specification as a dictionary.\n\n    ## Example\n\n    ```python\n    import pynetbox\n    nb = pynetbox.api(\n        'http://localhost:8000',\n        token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n    )\n    nb.openapi()\n    # {...}\n    ```\n    \"\"\"\n    if not (openapi := getattr(self, \"_openapi\", None)):\n        openapi = self._openapi = Request(\n            base=self.base_url,\n            http_session=self.http_session,\n        ).get_openapi()\n\n    return openapi\n</code></pre>"},{"location":"#pynetbox.core.api.Api.status","title":"<code>status(self)</code>","text":"<p>Gets the status information from NetBox.</p>"},{"location":"#pynetbox.core.api.Api.status--returns","title":"Returns","text":"<p>Dictionary containing NetBox status information.</p>"},{"location":"#pynetbox.core.api.Api.status--raises","title":"Raises","text":"<p><code>RequestError</code>: If the request is not successful.</p>"},{"location":"#pynetbox.core.api.Api.status--example","title":"Example","text":"<pre><code>from pprint import pprint\npprint(nb.status())\n{\n    'django-version': '3.1.3',\n    'installed-apps': {\n        'cacheops': '5.0.1',\n        'debug_toolbar': '3.1.1',\n        'django_filters': '2.4.0',\n        'django_prometheus': '2.1.0',\n        'django_rq': '2.4.0',\n        'django_tables2': '2.3.3',\n        'drf_yasg': '1.20.0',\n        'mptt': '0.11.0',\n        'rest_framework': '3.12.2',\n        'taggit': '1.3.0',\n        'timezone_field': '4.0'\n    },\n    'netbox-version': '2.10.2',\n    'plugins': {},\n    'python-version': '3.7.3',\n    'rq-workers-running': 1\n}\n</code></pre> Source code in <code>pynetbox/core/api.py</code> <pre><code>def status(self):\n    \"\"\"Gets the status information from NetBox.\n\n    ## Returns\n    Dictionary containing NetBox status information.\n\n    ## Raises\n    `RequestError`: If the request is not successful.\n\n    ## Example\n\n    ```python\n    from pprint import pprint\n    pprint(nb.status())\n    {\n        'django-version': '3.1.3',\n        'installed-apps': {\n            'cacheops': '5.0.1',\n            'debug_toolbar': '3.1.1',\n            'django_filters': '2.4.0',\n            'django_prometheus': '2.1.0',\n            'django_rq': '2.4.0',\n            'django_tables2': '2.3.3',\n            'drf_yasg': '1.20.0',\n            'mptt': '0.11.0',\n            'rest_framework': '3.12.2',\n            'taggit': '1.3.0',\n            'timezone_field': '4.0'\n        },\n        'netbox-version': '2.10.2',\n        'plugins': {},\n        'python-version': '3.7.3',\n        'rq-workers-running': 1\n    }\n    ```\n    \"\"\"\n    status = Request(\n        base=self.base_url,\n        token=self.token,\n        http_session=self.http_session,\n    ).get_status()\n    return status\n</code></pre>"},{"location":"#app-reference","title":"App Reference","text":""},{"location":"#pynetbox.core.app.App","title":"<code> pynetbox.core.app.App        </code>","text":"<p>Represents apps in NetBox.</p> <p>Calls to attributes are returned as Endpoint objects.</p>"},{"location":"#pynetbox.core.app.App--returns","title":"Returns","text":"<p>Endpoint matching requested attribute.</p>"},{"location":"#pynetbox.core.app.App--raises","title":"Raises","text":"<p>RequestError if requested endpoint doesn't exist.</p> Source code in <code>pynetbox/core/app.py</code> <pre><code>class App:\n    \"\"\"Represents apps in NetBox.\n\n    Calls to attributes are returned as Endpoint objects.\n\n    ## Returns\n    Endpoint matching requested attribute.\n\n    ## Raises\n    RequestError if requested endpoint doesn't exist.\n    \"\"\"\n\n    def __init__(self, api, name):\n        self.api = api\n        self.name = name\n        self._setmodel()\n\n    models = {\n        \"dcim\": dcim,\n        \"ipam\": ipam,\n        \"circuits\": circuits,\n        \"virtualization\": virtualization,\n        \"extras\": extras,\n        \"users\": users,\n        \"wireless\": wireless,\n    }\n\n    def _setmodel(self):\n        self.model = App.models[self.name] if self.name in App.models else None\n\n    def __getstate__(self):\n        return {\"api\": self.api, \"name\": self.name}\n\n    def __setstate__(self, d):\n        self.__dict__.update(d)\n        self._setmodel()\n\n    def __getattr__(self, name):\n        return Endpoint(self.api, self, name, model=self.model)\n\n    def config(self):\n        \"\"\"Returns config response from app.\n\n        ## Returns\n        Raw response from NetBox's config endpoint.\n\n        ## Raises\n        RequestError if called for an invalid endpoint.\n\n        ## Examples\n\n        ```python\n        pprint.pprint(nb.users.config())\n        {\n            'tables': {\n                'DeviceTable': {\n                    'columns': [\n                        'name',\n                        'status',\n                        'tenant',\n                        'role',\n                        'site',\n                        'primary_ip',\n                        'tags'\n                    ]\n                }\n            }\n        }\n        ```\n        \"\"\"\n        config = Request(\n            base=\"{}/{}/config/\".format(\n                self.api.base_url,\n                self.name,\n            ),\n            token=self.api.token,\n            http_session=self.api.http_session,\n        ).get()\n        return config\n</code></pre>"},{"location":"#pynetbox.core.app.App.config","title":"<code>config(self)</code>","text":"<p>Returns config response from app.</p>"},{"location":"#pynetbox.core.app.App.config--returns","title":"Returns","text":"<p>Raw response from NetBox's config endpoint.</p>"},{"location":"#pynetbox.core.app.App.config--raises","title":"Raises","text":"<p>RequestError if called for an invalid endpoint.</p>"},{"location":"#pynetbox.core.app.App.config--examples","title":"Examples","text":"<pre><code>pprint.pprint(nb.users.config())\n{\n    'tables': {\n        'DeviceTable': {\n            'columns': [\n                'name',\n                'status',\n                'tenant',\n                'role',\n                'site',\n                'primary_ip',\n                'tags'\n            ]\n        }\n    }\n}\n</code></pre> Source code in <code>pynetbox/core/app.py</code> <pre><code>def config(self):\n    \"\"\"Returns config response from app.\n\n    ## Returns\n    Raw response from NetBox's config endpoint.\n\n    ## Raises\n    RequestError if called for an invalid endpoint.\n\n    ## Examples\n\n    ```python\n    pprint.pprint(nb.users.config())\n    {\n        'tables': {\n            'DeviceTable': {\n                'columns': [\n                    'name',\n                    'status',\n                    'tenant',\n                    'role',\n                    'site',\n                    'primary_ip',\n                    'tags'\n                ]\n            }\n        }\n    }\n    ```\n    \"\"\"\n    config = Request(\n        base=\"{}/{}/config/\".format(\n            self.api.base_url,\n            self.name,\n        ),\n        token=self.api.token,\n        http_session=self.api.http_session,\n    ).get()\n    return config\n</code></pre>"},{"location":"IPAM/","title":"IPAM","text":""},{"location":"IPAM/#pynetbox.models.ipam.Prefixes","title":"<code> pynetbox.models.ipam.Prefixes            (Record)         </code>","text":"Source code in <code>pynetbox/models/ipam.py</code> <pre><code>class Prefixes(Record):\n    def __str__(self):\n        return str(self.prefix)\n\n    @property\n    def available_ips(self):\n        \"\"\"Represents the ``available-ips`` detail endpoint.\n\n        Returns a DetailEndpoint object that is the interface for\n        viewing and creating IP addresses inside a prefix.\n\n        ## Returns\n        DetailEndpoint object.\n\n        ## Examples\n\n        ```python\n        prefix = nb.ipam.prefixes.get(24)\n        prefix.available_ips.list()\n        # [10.0.0.1/24, 10.0.0.2/24, 10.0.0.3/24, 10.0.0.4/24, 10.0.0.5/24, ...]\n        ```\n\n        To create a single IP:\n\n        ```python\n        prefix = nb.ipam.prefixes.get(24)\n        prefix.available_ips.create()\n        # 10.0.0.1/24\n        ```\n\n        To create multiple IPs:\n\n        ```python\n        prefix = nb.ipam.prefixes.get(24)\n        create = prefix.available_ips.create([{} for i in range(2)])\n        # [10.0.0.2/24, 10.0.0.3/24]\n        ```\n        \"\"\"\n        return DetailEndpoint(self, \"available-ips\", custom_return=IpAddresses)\n\n    @property\n    def available_prefixes(self):\n        \"\"\"Represents the ``available-prefixes`` detail endpoint.\n\n        Returns a DetailEndpoint object that is the interface for\n        viewing and creating prefixes inside a parent prefix.\n\n        Very similar to `available_ips`, except that dict (or list of dicts) passed to `.create()`\n        needs to have a `prefix_length` key/value specified.\n\n        ## Returns\n        DetailEndpoint object.\n\n        ## Examples\n\n        ```python\n        prefix = nb.ipam.prefixes.get(3)\n        prefix\n        # 10.0.0.0/16\n        prefix.available_prefixes.list()\n        # [10.0.1.0/24, 10.0.2.0/23, 10.0.4.0/22, 10.0.8.0/21, 10.0.16.0/20, 10.0.32.0/19, 10.0.64.0/18, 10.0.128.0/17]\n        ```\n\n        Creating a single child prefix:\n\n        ```python\n        prefix = nb.ipam.prefixes.get(1)\n        prefix\n        # 10.0.0.0/24\n        new_prefix = prefix.available_prefixes.create(\n            {\"prefix_length\": 29}\n        )\n        # 10.0.0.16/29\n        ```\n        \"\"\"\n        return DetailEndpoint(self, \"available-prefixes\", custom_return=Prefixes)\n</code></pre>"},{"location":"IPAM/#pynetbox.models.ipam.Prefixes.available_ips","title":"<code>available_ips</code>  <code>property</code> <code>readonly</code>","text":"<p>Represents the <code>available-ips</code> detail endpoint.</p> <p>Returns a DetailEndpoint object that is the interface for viewing and creating IP addresses inside a prefix.</p>"},{"location":"IPAM/#pynetbox.models.ipam.Prefixes.available_ips--returns","title":"Returns","text":"<p>DetailEndpoint object.</p>"},{"location":"IPAM/#pynetbox.models.ipam.Prefixes.available_ips--examples","title":"Examples","text":"<pre><code>prefix = nb.ipam.prefixes.get(24)\nprefix.available_ips.list()\n# [10.0.0.1/24, 10.0.0.2/24, 10.0.0.3/24, 10.0.0.4/24, 10.0.0.5/24, ...]\n</code></pre> <p>To create a single IP:</p> <pre><code>prefix = nb.ipam.prefixes.get(24)\nprefix.available_ips.create()\n# 10.0.0.1/24\n</code></pre> <p>To create multiple IPs:</p> <pre><code>prefix = nb.ipam.prefixes.get(24)\ncreate = prefix.available_ips.create([{} for i in range(2)])\n# [10.0.0.2/24, 10.0.0.3/24]\n</code></pre>"},{"location":"IPAM/#pynetbox.models.ipam.Prefixes.available_prefixes","title":"<code>available_prefixes</code>  <code>property</code> <code>readonly</code>","text":"<p>Represents the <code>available-prefixes</code> detail endpoint.</p> <p>Returns a DetailEndpoint object that is the interface for viewing and creating prefixes inside a parent prefix.</p> <p>Very similar to <code>available_ips</code>, except that dict (or list of dicts) passed to <code>.create()</code> needs to have a <code>prefix_length</code> key/value specified.</p>"},{"location":"IPAM/#pynetbox.models.ipam.Prefixes.available_prefixes--returns","title":"Returns","text":"<p>DetailEndpoint object.</p>"},{"location":"IPAM/#pynetbox.models.ipam.Prefixes.available_prefixes--examples","title":"Examples","text":"<pre><code>prefix = nb.ipam.prefixes.get(3)\nprefix\n# 10.0.0.0/16\nprefix.available_prefixes.list()\n# [10.0.1.0/24, 10.0.2.0/23, 10.0.4.0/22, 10.0.8.0/21, 10.0.16.0/20, 10.0.32.0/19, 10.0.64.0/18, 10.0.128.0/17]\n</code></pre> <p>Creating a single child prefix:</p> <pre><code>prefix = nb.ipam.prefixes.get(1)\nprefix\n# 10.0.0.0/24\nnew_prefix = prefix.available_prefixes.create(\n    {\"prefix_length\": 29}\n)\n# 10.0.0.16/29\n</code></pre>"},{"location":"IPAM/#pynetbox.models.ipam.VlanGroups","title":"<code> pynetbox.models.ipam.VlanGroups            (Record)         </code>","text":"Source code in <code>pynetbox/models/ipam.py</code> <pre><code>class VlanGroups(Record):\n    @property\n    def available_vlans(self):\n        \"\"\"Represents the ``available-vlans`` detail endpoint.\n\n        Returns a DetailEndpoint object that is the interface for\n        viewing and creating VLANs inside a VLAN group.\n\n        ## Returns\n        DetailEndpoint object.\n\n        ## Examples\n\n        ```python\n        vlan_group = nb.ipam.vlan_groups.get(1)\n        vlan_group.available_vlans.list()\n        # [10, 11, 12]\n        ```\n\n        To create a new VLAN:\n\n        ```python\n        vlan_group.available_vlans.create({\"name\": \"NewVLAN\"})\n        # NewVLAN (10)\n        ```\n        \"\"\"\n        return DetailEndpoint(self, \"available-vlans\", custom_return=Vlans)\n</code></pre>"},{"location":"IPAM/#pynetbox.models.ipam.VlanGroups.available_vlans","title":"<code>available_vlans</code>  <code>property</code> <code>readonly</code>","text":"<p>Represents the <code>available-vlans</code> detail endpoint.</p> <p>Returns a DetailEndpoint object that is the interface for viewing and creating VLANs inside a VLAN group.</p>"},{"location":"IPAM/#pynetbox.models.ipam.VlanGroups.available_vlans--returns","title":"Returns","text":"<p>DetailEndpoint object.</p>"},{"location":"IPAM/#pynetbox.models.ipam.VlanGroups.available_vlans--examples","title":"Examples","text":"<pre><code>vlan_group = nb.ipam.vlan_groups.get(1)\nvlan_group.available_vlans.list()\n# [10, 11, 12]\n</code></pre> <p>To create a new VLAN:</p> <pre><code>vlan_group.available_vlans.create({\"name\": \"NewVLAN\"})\n# NewVLAN (10)\n</code></pre>"},{"location":"advanced/","title":"Custom Sessions","text":"<p>Custom sessions can be used to modify the default HTTP behavior. Below are a few examples, most of them from here.</p>"},{"location":"advanced/#headers","title":"Headers","text":"<p>To set a custom header on all requests. These headers are automatically merged with headers pynetbox sets itself.</p> <p>Example:</p> <pre><code>import pynetbox\nimport requests\nsession = requests.Session()\nsession.headers = {\"mycustomheader\": \"test\"}\nnb = pynetbox.api(\n    'http://localhost:8000',\n    token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n)\nnb.http_session = session\n</code></pre>"},{"location":"advanced/#ssl-verification","title":"SSL Verification","text":"<p>To disable SSL verification. See the docs.</p> <p>Example:</p> <pre><code>import pynetbox\nimport requests\nsession = requests.Session()\nsession.verify = False\nnb = pynetbox.api(\n    'http://localhost:8000',\n    token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n)\nnb.http_session = session\n</code></pre>"},{"location":"advanced/#timeouts","title":"Timeouts","text":"<p>Setting timeouts requires the use of Adapters.</p> <p>Example:</p> <pre><code>from requests.adapters import HTTPAdapter\n\nclass TimeoutHTTPAdapter(HTTPAdapter):\n    def __init__(self, *args, **kwargs):\n        self.timeout = kwargs.get(\"timeout\", 5)\n        super().__init__(*args, **kwargs)\n\n    def send(self, request, **kwargs):\n        kwargs['timeout'] = self.timeout\n        return super().send(request, **kwargs)\n\nadapter = TimeoutHTTPAdapter()\nsession = requests.Session()\nsession.mount(\"http://\", adapter)\nsession.mount(\"https://\", adapter)\n\nnb = pynetbox.api(\n    'http://localhost:8000',\n    token='d6f4e314a5b5fefd164995169f28ae32d987704f'\n)\nnb.http_session = session\n</code></pre>"},{"location":"branching/","title":"Branching Plugin","text":"<p>The NetBox branching plugin allows you to create and work with branches in NetBox, similar to version control systems. This enables you to make changes in isolation and merge them back to the main branch when ready.</p>"},{"location":"branching/#activating-branches","title":"Activating Branches","text":"<p>The <code>activate_branch</code> context manager allows you to perform operations within a specific branch's schema. All operations performed within the context manager will use that branch's schema.</p> <pre><code>import pynetbox\n\n# Initialize the API\nnb = pynetbox.api(\n    \"http://localhost:8000\",\n    token=\"your-token-here\"\n)\n\n# Get an existing branch\nbranch = nb.plugins.branching.branches.get(id=1)\n\n# Activate the branch for operations\nwith nb.activate_branch(branch):\n    # All operations within this block will use the branch's schema\n    sites = nb.dcim.sites.all()\n    # Make changes to objects...\n    # These changes will only exist in this branch\n</code></pre>"},{"location":"branching/#waiting-for-branch-status","title":"Waiting for Branch Status","text":"<p>When working with branches, you often need to wait for certain status changes, such as when a branch becomes ready after creation or when a merge operation completes. The tenacity library provides a robust way to handle these waiting scenarios.</p> <p>First, install tenacity:</p> <pre><code>pip install tenacity\n</code></pre> <p>Here's how to create a reusable function to wait for branch status changes:</p> <pre><code>from tenacity import retry, retry_if_result, stop_after_attempt, wait_exponential\nimport pynetbox\n\n@retry(\n    stop=stop_after_attempt(30),  # Try for up to 30 attempts\n    wait=wait_exponential(\n        multiplier=1, min=4, max=60\n    ),  # Wait between 4-60 seconds, increasing exponentially\n    retry=retry_if_result(lambda x: not x),  # Retry if the status check returns False\n)\ndef wait_for_branch_status(branch, target_status):\n    \"\"\"Wait for branch to reach a specific status, with exponential backoff.\"\"\"\n    branch = nb.plugins.branching.branches.get(branch.id)\n    return str(branch.status) == target_status\n\n# Example usage:\nbranch = nb.plugins.branching.branches.create(name=\"my-branch\")\n\n# Wait for branch to be ready\nwait_for_branch_status(branch, \"Ready\")\n\n# Get the latest branch status\nbranch = nb.plugins.branching.branches.get(branch.id)\nprint(f\"Branch is now ready! Status: {branch.status}\")\n</code></pre> <p>The function will:</p> <ol> <li>Check the current status of the branch</li> <li>If the status doesn't match the target status, it will retry with exponential backoff</li> <li>Continue retrying until either:<ul> <li>The branch reaches the target status</li> <li>The maximum number of attempts (30) is reached</li> <li>The maximum wait time (60 seconds) is exceeded</li> </ul> </li> </ol> <p>The exponential backoff ensures that we don't overwhelm the server with requests while still checking frequently enough to catch status changes quickly. </p>"},{"location":"endpoint/","title":"Endpoint","text":""},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint","title":"<code> pynetbox.core.endpoint.Endpoint        </code>","text":"<p>Represent actions available on endpoints in the Netbox API.</p> <p>Takes <code>name</code> and <code>app</code> passed from App() and builds the correct url to make queries to and the proper Response object to return results in.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint--parameters","title":"Parameters","text":"<ul> <li>api (Api): Takes Api created at instantiation.</li> <li>app (App): Takes App.</li> <li>name (str): Name of endpoint passed to App().</li> <li>model (obj, optional): Custom model for given app.</li> </ul>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint--note","title":"Note","text":"<p>In order to call NetBox endpoints with dashes in their names you should convert the dash to an underscore. (E.g. querying the ip-addresses endpoint is done with <code>nb.ipam.ip_addresses.all()</code>.)</p> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>class Endpoint:\n    \"\"\"Represent actions available on endpoints in the Netbox API.\n\n    Takes ``name`` and ``app`` passed from App() and builds the correct\n    url to make queries to and the proper Response object to return\n    results in.\n\n    ## Parameters\n\n    * **api** (Api): Takes Api created at instantiation.\n    * **app** (App): Takes App.\n    * **name** (str): Name of endpoint passed to App().\n    * **model** (obj, optional): Custom model for given app.\n\n    ## Note\n\n    In order to call NetBox endpoints with dashes in their\n    names you should convert the dash to an underscore.\n    (E.g. querying the ip-addresses endpoint is done with\n    ``nb.ipam.ip_addresses.all()``.)\n    \"\"\"\n\n    def __init__(self, api, app, name, model=None):\n        self.return_obj = self._lookup_ret_obj(name, model)\n        self.name = name.replace(\"_\", \"-\")\n        self.api = api\n        self.app = app\n        self.base_url = api.base_url\n        self.token = api.token\n        self.url = \"{base_url}/{app}/{endpoint}\".format(\n            base_url=self.base_url,\n            app=app.name,\n            endpoint=self.name,\n        )\n        self._choices = None\n\n    def _lookup_ret_obj(self, name, model):\n        \"\"\"Loads unique Response objects.\n\n        This method loads a unique response object for an endpoint if\n        it exists. Otherwise return a generic `Record` object.\n\n        ## Parameters\n\n        * **name** (str): Endpoint name.\n        * **model** (obj): The application model that contains unique Record objects.\n\n        ## Returns\n        Record (obj)\n        \"\"\"\n        if model:\n            name = name.title().replace(\"_\", \"\")\n            ret = getattr(model, name, Record)\n        else:\n            ret = Record\n        return ret\n\n    def _validate_openapi_parameters(self, method: str, parameters: dict) -&gt; None:\n        \"\"\"Validate GET request parameters against OpenAPI specification\n\n        This method raises a **ParameterValidationError** if parameters passed to NetBox API\n        do not match the OpenAPI specification or validation fails.\n\n        ## Parameters\n\n        * **method** : Only \"get\" is supported as for other methods NetBox already does proper validation\n        * **parameters** : kwargs passed to filter() method\n\n        ## Returns\n        None\n        \"\"\"\n        if method.lower() != \"get\":\n            raise RuntimeError(f\"Unsupported method '{method}'.\")\n\n        openapi_definition_path = \"/api/{app}/{endpoint}/\".format(\n            app=self.app.name,\n            endpoint=self.name,\n        )\n\n        # Parse NetBox OpenAPI definition\n        try:\n            openapi_definition = self.api.openapi()[\"paths\"].get(\n                openapi_definition_path\n            )\n\n            if not openapi_definition:\n                raise ParameterValidationError(\n                    f\"Path '{openapi_definition_path}' does not exist in NetBox OpenAPI specification.\"\n                )\n\n            openapi_parameters = openapi_definition[method][\"parameters\"]\n            allowed_parameters = [p[\"name\"] for p in openapi_parameters]\n\n        except KeyError as exc:\n            raise ParameterValidationError(\n                f\"Error while parsing Netbox OpenAPI specification: {exc}\"\n            )\n\n        # Validate all parameters\n        validation_errors = []\n        for p in parameters:\n            if p not in allowed_parameters:\n                validation_errors.append(\n                    f\"'{p}' is not allowed as parameter on path '{openapi_definition_path}'.\"\n                )\n\n        if len(validation_errors) &gt; 0:\n            raise ParameterValidationError(validation_errors)\n\n    def all(self, limit=0, offset=None):\n        \"\"\"Queries the 'ListView' of a given endpoint.\n\n        Returns all objects from an endpoint.\n\n        ## Parameters\n\n        * **limit** (int, optional): Overrides the max page size on\n            paginated returns. This defines the number of records that will\n            be returned with each query to the Netbox server. The queries\n            will be made as you iterate through the result set.\n        * **offset** (int, optional): Overrides the offset on paginated returns.\n\n        ## Returns\n        A RecordSet object.\n\n        ## Examples\n\n        ```python\n        devices = list(nb.dcim.devices.all())\n        for device in devices:\n            print(device.name)\n\n        # test1-leaf1\n        # test1-leaf2\n        # test1-leaf3\n        ```\n\n        If you want to iterate over the results multiple times then\n        encapsulate them in a list like this:\n        ```python\n        devices = list(nb.dcim.devices.all())\n        ```\n\n        This will cause the entire result set\n        to be fetched from the server.\n        \"\"\"\n        if limit == 0 and offset is not None:\n            raise ValueError(\"offset requires a positive limit value\")\n        req = Request(\n            base=\"{}/\".format(self.url),\n            token=self.token,\n            http_session=self.api.http_session,\n            threading=self.api.threading,\n            limit=limit,\n            offset=offset,\n        )\n\n        return RecordSet(self, req)\n\n    def get(self, *args, **kwargs):\n        \"\"\"Queries the DetailsView of a given endpoint.\n\n        ## Parameters\n\n        * **key** (int, optional): id for the item to be retrieved.\n        * **kwargs**: Accepts the same keyword args as filter(). Any search argument the endpoint accepts can\n            be added as a keyword arg.\n        * **strict_filters** (bool, optional): Overrides the global filter\n            validation per-request basis. Handled by the filter() method.\n\n        ## Returns\n        A single Record object or None\n\n        ## Raises\n        ValueError: if kwarg search return more than one value.\n\n        ## Examples\n\n        Referencing with a kwarg that only returns one value:\n\n        ```python\n        nb.dcim.devices.get(name='test1-a3-tor1b')\n        # test1-a3-tor1b\n        ```\n\n        Referencing with an id:\n\n        ```python\n        nb.dcim.devices.get(1)\n        # test1-edge1\n        ```\n\n        Using multiple named arguments. For example, retrieving the location when the location name is not unique and used in multiple sites:\n\n        ```python\n        nb.locations.get(site='site-1', name='Row 1')\n        # Row 1\n        ```\n        \"\"\"\n        try:\n            key = args[0]\n        except IndexError:\n            key = None\n\n        if not key:\n            resp = self.filter(**kwargs)\n            ret = next(resp, None)\n            if not ret:\n                return ret\n            try:\n                next(resp)\n                raise ValueError(\n                    \"get() returned more than one result. \"\n                    \"Check that the kwarg(s) passed are valid for this \"\n                    \"endpoint or use filter() or all() instead.\"\n                )\n            except StopIteration:\n                return ret\n\n        req = Request(\n            key=key,\n            base=self.url,\n            token=self.token,\n            http_session=self.api.http_session,\n        )\n        try:\n            return next(RecordSet(self, req), None)\n        except RequestError as e:\n            if e.req.status_code == 404:\n                return None\n            else:\n                raise e\n\n    def filter(self, *args, **kwargs):\n        \"\"\"Queries the 'ListView' of a given endpoint.\n\n        Takes named arguments that match the usable filters on a\n        given endpoint. If an argument is passed then it's used as a\n        freeform search argument if the endpoint supports it.\n\n        ## Parameters\n\n        * **args** (str, optional): Freeform search string that's\n            accepted on given endpoint.\n        * **kwargs** (str, optional): Any search argument the\n            endpoint accepts can be added as a keyword arg.\n        * **limit** (int, optional): Overrides the max page size on\n            paginated returns. This defines the number of records that will\n            be returned with each query to the Netbox server. The queries\n            will be made as you iterate through the result set.\n        * **offset** (int, optional): Overrides the offset on paginated returns.\n        * **strict_filters** (bool, optional): Overrides the global filter\n            validation per-request basis.\n\n        ## Returns\n        A RecordSet object.\n\n        ## Examples\n\n        To return a list of objects matching a named argument filter:\n\n        ```python\n        devices = nb.dcim.devices.filter(role='leaf-switch')\n        for device in devices:\n            print(device.name)\n\n        # test1-leaf1\n        # test1-leaf2\n        # test1-leaf3\n        ```\n\n        ```python\n        devices = nb.dcim.devices.filter(site='site-1')\n        for device in devices:\n            print(device.name)\n\n        # test1-a2-leaf1\n        # test2-a2-leaf2\n        ```\n\n        ## Note\n\n        If a keyword argument is incorrect a `TypeError` will not be returned by pynetbox.\n        Instead, pynetbox will return all records filtered up to the last correct keyword argument. For example, if we used `site=\"Site 1\"` instead of `site=site-1` when using filter on\n        the devices endpoint, then pynetbox will return **all** devices across all sites instead of devices at Site 1.\n\n        Using a freeform query along with a named argument:\n\n        ```python\n        devices = nb.dcim.devices.filter('a3', role='leaf-switch')\n        for device in devices:\n            print(device.name)\n\n        # test1-a3-leaf1\n        # test1-a3-leaf2\n        ```\n        \"\"\"\n\n        if args:\n            kwargs.update({\"q\": args[0]})\n\n        if any(i in RESERVED_KWARGS for i in kwargs):\n            raise ValueError(\n                \"A reserved kwarg was passed ({}). Please remove it \"\n                \"and try again.\".format(RESERVED_KWARGS)\n            )\n        limit = kwargs.pop(\"limit\") if \"limit\" in kwargs else 0\n        offset = kwargs.pop(\"offset\") if \"offset\" in kwargs else None\n        strict_filters = (\n            # kwargs value takes precedence on globally set value\n            kwargs.pop(\"strict_filters\")\n            if \"strict_filters\" in kwargs\n            else self.api.strict_filters\n        )\n\n        if limit == 0 and offset is not None:\n            raise ValueError(\"offset requires a positive limit value\")\n        filters = {x: y if y is not None else \"null\" for x, y in kwargs.items()}\n\n        if strict_filters:\n            self._validate_openapi_parameters(\"get\", filters)\n\n        req = Request(\n            filters=filters,\n            base=self.url,\n            token=self.token,\n            http_session=self.api.http_session,\n            threading=self.api.threading,\n            limit=limit,\n            offset=offset,\n        )\n\n        return RecordSet(self, req)\n\n    def create(self, *args, **kwargs):\n        \"\"\"Creates an object on an endpoint.\n\n        Takes named arguments that match the given endpoint's\n        available fields. Returns a new object.\n\n        ## Parameters\n\n        * **args**: Not used.\n        * **kwargs**: Fields and values to create the object with.\n\n        ## Returns\n        A Record object.\n\n        ## Examples\n\n        Creating a new device:\n\n        ```python\n        new_device = nb.dcim.devices.create(\n            name='test-device',\n            device_type=1,\n            device_role=1,\n            site=1\n        )\n        ```\n\n        Creating a new device with a nested object:\n\n        ```python\n        new_device = nb.dcim.devices.create(\n            name='test-device',\n            device_type={'id': 1},\n            device_role={'id': 1},\n            site={'id': 1}\n        )\n        ```\n        \"\"\"\n\n        req = Request(\n            base=self.url,\n            token=self.token,\n            http_session=self.api.http_session,\n        ).post(args[0] if args else kwargs)\n\n        if isinstance(req, list):\n            return [self.return_obj(i, self.api, self) for i in req]\n        return self.return_obj(req, self.api, self)\n\n    def update(self, objects):\n        \"\"\"Updates objects in NetBox.\n\n        Takes a list of objects and updates them in NetBox.\n\n        ## Parameters\n\n        * **objects** (list): A list of Record objects to update.\n\n        ## Returns\n        A list of Record objects.\n\n        ## Examples\n\n        ```python\n        devices = nb.dcim.devices.filter(site='test1')\n        for device in devices:\n            device.status = 'active'\n        nb.dcim.devices.update(devices)\n        ```\n        \"\"\"\n        series = []\n        if not isinstance(objects, list):\n            raise ValueError(\n                \"Objects passed must be list[dict|Record] - was {}\".format(\n                    type(objects)\n                )\n            )\n        for o in objects:\n            if isinstance(o, Record):\n                data = o.updates()\n                if data:\n                    data[\"id\"] = o.id\n                    series.append(data)\n            elif isinstance(o, dict):\n                if \"id\" not in o:\n                    raise ValueError(\"id is missing from object: \" + str(o))\n                series.append(o)\n            else:\n                raise ValueError(\n                    \"Object passed must be dict|Record - was {}\".format(type(objects))\n                )\n        req = Request(\n            base=self.url,\n            token=self.token,\n            http_session=self.api.http_session,\n        ).patch(series)\n\n        if isinstance(req, list):\n            return [self.return_obj(i, self.api, self) for i in req]\n        return self.return_obj(req, self.api, self)\n\n    def delete(self, objects):\n        \"\"\"Deletes objects from NetBox.\n\n        Takes a list of objects and deletes them from NetBox.\n\n        ## Parameters\n\n        * **objects** (list): A list of Record objects to delete.\n\n        ## Returns\n        True if the delete operation was successful.\n\n        ## Examples\n\n        ```python\n        devices = nb.dcim.devices.filter(site='test1')\n        nb.dcim.devices.delete(devices)\n        ```\n        \"\"\"\n        cleaned_ids = []\n        if not isinstance(objects, list) and not isinstance(objects, RecordSet):\n            raise ValueError(\n                \"objects must be list[str|int|Record]\"\n                \"|RecordSet - was \" + str(type(objects))\n            )\n        for o in objects:\n            if isinstance(o, int):\n                cleaned_ids.append(o)\n            elif isinstance(o, str) and o.isnumeric():\n                cleaned_ids.append(int(o))\n            elif isinstance(o, Record):\n                if not hasattr(o, \"id\"):\n                    raise ValueError(\n                        \"Record from '\"\n                        + o.url\n                        + \"' does not have an id and cannot be bulk deleted\"\n                    )\n                cleaned_ids.append(o.id)\n            else:\n                raise ValueError(\n                    \"Invalid object in list of objects to delete: \" + str(type(o))\n                )\n\n        req = Request(\n            base=self.url,\n            token=self.token,\n            http_session=self.api.http_session,\n        )\n        return True if req.delete(data=[{\"id\": i} for i in cleaned_ids]) else False\n\n    def choices(self):\n        \"\"\"Returns all choices from the endpoint if it has them.\n\n        ## Returns\n        Dictionary of available choices.\n\n        ## Examples\n\n        ```python\n        choices = nb.dcim.devices.choices()\n        print(choices['status'])\n        {\n            'label': 'Active',\n            'value': 'active'\n        }\n        ```\n        \"\"\"\n        if self._choices:\n            return self._choices\n\n        req = Request(\n            base=self.url,\n            token=self.api.token,\n            http_session=self.api.http_session,\n        ).options()\n\n        actions = req.get(\"actions\", {})\n        post_data = actions.get(\"POST\") or actions.get(\"PUT\")\n        if post_data is None:\n            raise ValueError(\n                \"Unexpected format in the OPTIONS response at {}\".format(self.url)\n            )\n        self._choices = {}\n        for prop in post_data:\n            if \"choices\" in post_data[prop]:\n                self._choices[prop] = post_data[prop][\"choices\"]\n\n        return self._choices\n\n    def count(self, *args, **kwargs):\n        \"\"\"Returns the count of objects in a query.\n\n        Takes named arguments that match the usable filters on a\n        given endpoint. If an argument is passed then it's used as a\n        freeform search argument if the endpoint supports it.\n\n        ## Parameters\n\n        * **args** (str, optional): Freeform search string that's\n            accepted on given endpoint.\n        * **kwargs** (str, optional): Any search argument the\n            endpoint accepts can be added as a keyword arg.\n\n        ## Returns\n        Integer of count of objects.\n\n        ## Examples\n\n        ```python\n        nb.dcim.devices.count(site='test1')\n        # 27\n        ```\n        \"\"\"\n\n        if args:\n            kwargs.update({\"q\": args[0]})\n\n        if any(i in RESERVED_KWARGS for i in kwargs):\n            raise ValueError(\n                \"A reserved {} kwarg was passed. Please remove it \"\n                \"try again.\".format(RESERVED_KWARGS)\n            )\n\n        ret = Request(\n            filters=kwargs,\n            base=self.url,\n            token=self.token,\n            http_session=self.api.http_session,\n        )\n\n        return ret.get_count()\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.all","title":"<code>all(self, limit=0, offset=None)</code>","text":"<p>Queries the 'ListView' of a given endpoint.</p> <p>Returns all objects from an endpoint.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.all--parameters","title":"Parameters","text":"<ul> <li>limit (int, optional): Overrides the max page size on     paginated returns. This defines the number of records that will     be returned with each query to the Netbox server. The queries     will be made as you iterate through the result set.</li> <li>offset (int, optional): Overrides the offset on paginated returns.</li> </ul>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.all--returns","title":"Returns","text":"<p>A RecordSet object.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.all--examples","title":"Examples","text":"<pre><code>devices = list(nb.dcim.devices.all())\nfor device in devices:\n    print(device.name)\n\n# test1-leaf1\n# test1-leaf2\n# test1-leaf3\n</code></pre> <p>If you want to iterate over the results multiple times then encapsulate them in a list like this: <pre><code>devices = list(nb.dcim.devices.all())\n</code></pre></p> <p>This will cause the entire result set to be fetched from the server.</p> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>def all(self, limit=0, offset=None):\n    \"\"\"Queries the 'ListView' of a given endpoint.\n\n    Returns all objects from an endpoint.\n\n    ## Parameters\n\n    * **limit** (int, optional): Overrides the max page size on\n        paginated returns. This defines the number of records that will\n        be returned with each query to the Netbox server. The queries\n        will be made as you iterate through the result set.\n    * **offset** (int, optional): Overrides the offset on paginated returns.\n\n    ## Returns\n    A RecordSet object.\n\n    ## Examples\n\n    ```python\n    devices = list(nb.dcim.devices.all())\n    for device in devices:\n        print(device.name)\n\n    # test1-leaf1\n    # test1-leaf2\n    # test1-leaf3\n    ```\n\n    If you want to iterate over the results multiple times then\n    encapsulate them in a list like this:\n    ```python\n    devices = list(nb.dcim.devices.all())\n    ```\n\n    This will cause the entire result set\n    to be fetched from the server.\n    \"\"\"\n    if limit == 0 and offset is not None:\n        raise ValueError(\"offset requires a positive limit value\")\n    req = Request(\n        base=\"{}/\".format(self.url),\n        token=self.token,\n        http_session=self.api.http_session,\n        threading=self.api.threading,\n        limit=limit,\n        offset=offset,\n    )\n\n    return RecordSet(self, req)\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.choices","title":"<code>choices(self)</code>","text":"<p>Returns all choices from the endpoint if it has them.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.choices--returns","title":"Returns","text":"<p>Dictionary of available choices.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.choices--examples","title":"Examples","text":"<pre><code>choices = nb.dcim.devices.choices()\nprint(choices['status'])\n{\n    'label': 'Active',\n    'value': 'active'\n}\n</code></pre> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>def choices(self):\n    \"\"\"Returns all choices from the endpoint if it has them.\n\n    ## Returns\n    Dictionary of available choices.\n\n    ## Examples\n\n    ```python\n    choices = nb.dcim.devices.choices()\n    print(choices['status'])\n    {\n        'label': 'Active',\n        'value': 'active'\n    }\n    ```\n    \"\"\"\n    if self._choices:\n        return self._choices\n\n    req = Request(\n        base=self.url,\n        token=self.api.token,\n        http_session=self.api.http_session,\n    ).options()\n\n    actions = req.get(\"actions\", {})\n    post_data = actions.get(\"POST\") or actions.get(\"PUT\")\n    if post_data is None:\n        raise ValueError(\n            \"Unexpected format in the OPTIONS response at {}\".format(self.url)\n        )\n    self._choices = {}\n    for prop in post_data:\n        if \"choices\" in post_data[prop]:\n            self._choices[prop] = post_data[prop][\"choices\"]\n\n    return self._choices\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.count","title":"<code>count(self, *args, **kwargs)</code>","text":"<p>Returns the count of objects in a query.</p> <p>Takes named arguments that match the usable filters on a given endpoint. If an argument is passed then it's used as a freeform search argument if the endpoint supports it.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.count--parameters","title":"Parameters","text":"<ul> <li>args (str, optional): Freeform search string that's     accepted on given endpoint.</li> <li>kwargs (str, optional): Any search argument the     endpoint accepts can be added as a keyword arg.</li> </ul>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.count--returns","title":"Returns","text":"<p>Integer of count of objects.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.count--examples","title":"Examples","text":"<pre><code>nb.dcim.devices.count(site='test1')\n# 27\n</code></pre> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>def count(self, *args, **kwargs):\n    \"\"\"Returns the count of objects in a query.\n\n    Takes named arguments that match the usable filters on a\n    given endpoint. If an argument is passed then it's used as a\n    freeform search argument if the endpoint supports it.\n\n    ## Parameters\n\n    * **args** (str, optional): Freeform search string that's\n        accepted on given endpoint.\n    * **kwargs** (str, optional): Any search argument the\n        endpoint accepts can be added as a keyword arg.\n\n    ## Returns\n    Integer of count of objects.\n\n    ## Examples\n\n    ```python\n    nb.dcim.devices.count(site='test1')\n    # 27\n    ```\n    \"\"\"\n\n    if args:\n        kwargs.update({\"q\": args[0]})\n\n    if any(i in RESERVED_KWARGS for i in kwargs):\n        raise ValueError(\n            \"A reserved {} kwarg was passed. Please remove it \"\n            \"try again.\".format(RESERVED_KWARGS)\n        )\n\n    ret = Request(\n        filters=kwargs,\n        base=self.url,\n        token=self.token,\n        http_session=self.api.http_session,\n    )\n\n    return ret.get_count()\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.create","title":"<code>create(self, *args, **kwargs)</code>","text":"<p>Creates an object on an endpoint.</p> <p>Takes named arguments that match the given endpoint's available fields. Returns a new object.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.create--parameters","title":"Parameters","text":"<ul> <li>args: Not used.</li> <li>kwargs: Fields and values to create the object with.</li> </ul>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.create--returns","title":"Returns","text":"<p>A Record object.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.create--examples","title":"Examples","text":"<p>Creating a new device:</p> <pre><code>new_device = nb.dcim.devices.create(\n    name='test-device',\n    device_type=1,\n    device_role=1,\n    site=1\n)\n</code></pre> <p>Creating a new device with a nested object:</p> <pre><code>new_device = nb.dcim.devices.create(\n    name='test-device',\n    device_type={'id': 1},\n    device_role={'id': 1},\n    site={'id': 1}\n)\n</code></pre> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>def create(self, *args, **kwargs):\n    \"\"\"Creates an object on an endpoint.\n\n    Takes named arguments that match the given endpoint's\n    available fields. Returns a new object.\n\n    ## Parameters\n\n    * **args**: Not used.\n    * **kwargs**: Fields and values to create the object with.\n\n    ## Returns\n    A Record object.\n\n    ## Examples\n\n    Creating a new device:\n\n    ```python\n    new_device = nb.dcim.devices.create(\n        name='test-device',\n        device_type=1,\n        device_role=1,\n        site=1\n    )\n    ```\n\n    Creating a new device with a nested object:\n\n    ```python\n    new_device = nb.dcim.devices.create(\n        name='test-device',\n        device_type={'id': 1},\n        device_role={'id': 1},\n        site={'id': 1}\n    )\n    ```\n    \"\"\"\n\n    req = Request(\n        base=self.url,\n        token=self.token,\n        http_session=self.api.http_session,\n    ).post(args[0] if args else kwargs)\n\n    if isinstance(req, list):\n        return [self.return_obj(i, self.api, self) for i in req]\n    return self.return_obj(req, self.api, self)\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.delete","title":"<code>delete(self, objects)</code>","text":"<p>Deletes objects from NetBox.</p> <p>Takes a list of objects and deletes them from NetBox.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.delete--parameters","title":"Parameters","text":"<ul> <li>objects (list): A list of Record objects to delete.</li> </ul>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.delete--returns","title":"Returns","text":"<p>True if the delete operation was successful.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.delete--examples","title":"Examples","text":"<pre><code>devices = nb.dcim.devices.filter(site='test1')\nnb.dcim.devices.delete(devices)\n</code></pre> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>def delete(self, objects):\n    \"\"\"Deletes objects from NetBox.\n\n    Takes a list of objects and deletes them from NetBox.\n\n    ## Parameters\n\n    * **objects** (list): A list of Record objects to delete.\n\n    ## Returns\n    True if the delete operation was successful.\n\n    ## Examples\n\n    ```python\n    devices = nb.dcim.devices.filter(site='test1')\n    nb.dcim.devices.delete(devices)\n    ```\n    \"\"\"\n    cleaned_ids = []\n    if not isinstance(objects, list) and not isinstance(objects, RecordSet):\n        raise ValueError(\n            \"objects must be list[str|int|Record]\"\n            \"|RecordSet - was \" + str(type(objects))\n        )\n    for o in objects:\n        if isinstance(o, int):\n            cleaned_ids.append(o)\n        elif isinstance(o, str) and o.isnumeric():\n            cleaned_ids.append(int(o))\n        elif isinstance(o, Record):\n            if not hasattr(o, \"id\"):\n                raise ValueError(\n                    \"Record from '\"\n                    + o.url\n                    + \"' does not have an id and cannot be bulk deleted\"\n                )\n            cleaned_ids.append(o.id)\n        else:\n            raise ValueError(\n                \"Invalid object in list of objects to delete: \" + str(type(o))\n            )\n\n    req = Request(\n        base=self.url,\n        token=self.token,\n        http_session=self.api.http_session,\n    )\n    return True if req.delete(data=[{\"id\": i} for i in cleaned_ids]) else False\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.filter","title":"<code>filter(self, *args, **kwargs)</code>","text":"<p>Queries the 'ListView' of a given endpoint.</p> <p>Takes named arguments that match the usable filters on a given endpoint. If an argument is passed then it's used as a freeform search argument if the endpoint supports it.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.filter--parameters","title":"Parameters","text":"<ul> <li>args (str, optional): Freeform search string that's     accepted on given endpoint.</li> <li>kwargs (str, optional): Any search argument the     endpoint accepts can be added as a keyword arg.</li> <li>limit (int, optional): Overrides the max page size on     paginated returns. This defines the number of records that will     be returned with each query to the Netbox server. The queries     will be made as you iterate through the result set.</li> <li>offset (int, optional): Overrides the offset on paginated returns.</li> <li>strict_filters (bool, optional): Overrides the global filter     validation per-request basis.</li> </ul>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.filter--returns","title":"Returns","text":"<p>A RecordSet object.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.filter--examples","title":"Examples","text":"<p>To return a list of objects matching a named argument filter:</p> <pre><code>devices = nb.dcim.devices.filter(role='leaf-switch')\nfor device in devices:\n    print(device.name)\n\n# test1-leaf1\n# test1-leaf2\n# test1-leaf3\n</code></pre> <pre><code>devices = nb.dcim.devices.filter(site='site-1')\nfor device in devices:\n    print(device.name)\n\n# test1-a2-leaf1\n# test2-a2-leaf2\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.filter--note","title":"Note","text":"<p>If a keyword argument is incorrect a <code>TypeError</code> will not be returned by pynetbox. Instead, pynetbox will return all records filtered up to the last correct keyword argument. For example, if we used <code>site=\"Site 1\"</code> instead of <code>site=site-1</code> when using filter on the devices endpoint, then pynetbox will return all devices across all sites instead of devices at Site 1.</p> <p>Using a freeform query along with a named argument:</p> <pre><code>devices = nb.dcim.devices.filter('a3', role='leaf-switch')\nfor device in devices:\n    print(device.name)\n\n# test1-a3-leaf1\n# test1-a3-leaf2\n</code></pre> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>def filter(self, *args, **kwargs):\n    \"\"\"Queries the 'ListView' of a given endpoint.\n\n    Takes named arguments that match the usable filters on a\n    given endpoint. If an argument is passed then it's used as a\n    freeform search argument if the endpoint supports it.\n\n    ## Parameters\n\n    * **args** (str, optional): Freeform search string that's\n        accepted on given endpoint.\n    * **kwargs** (str, optional): Any search argument the\n        endpoint accepts can be added as a keyword arg.\n    * **limit** (int, optional): Overrides the max page size on\n        paginated returns. This defines the number of records that will\n        be returned with each query to the Netbox server. The queries\n        will be made as you iterate through the result set.\n    * **offset** (int, optional): Overrides the offset on paginated returns.\n    * **strict_filters** (bool, optional): Overrides the global filter\n        validation per-request basis.\n\n    ## Returns\n    A RecordSet object.\n\n    ## Examples\n\n    To return a list of objects matching a named argument filter:\n\n    ```python\n    devices = nb.dcim.devices.filter(role='leaf-switch')\n    for device in devices:\n        print(device.name)\n\n    # test1-leaf1\n    # test1-leaf2\n    # test1-leaf3\n    ```\n\n    ```python\n    devices = nb.dcim.devices.filter(site='site-1')\n    for device in devices:\n        print(device.name)\n\n    # test1-a2-leaf1\n    # test2-a2-leaf2\n    ```\n\n    ## Note\n\n    If a keyword argument is incorrect a `TypeError` will not be returned by pynetbox.\n    Instead, pynetbox will return all records filtered up to the last correct keyword argument. For example, if we used `site=\"Site 1\"` instead of `site=site-1` when using filter on\n    the devices endpoint, then pynetbox will return **all** devices across all sites instead of devices at Site 1.\n\n    Using a freeform query along with a named argument:\n\n    ```python\n    devices = nb.dcim.devices.filter('a3', role='leaf-switch')\n    for device in devices:\n        print(device.name)\n\n    # test1-a3-leaf1\n    # test1-a3-leaf2\n    ```\n    \"\"\"\n\n    if args:\n        kwargs.update({\"q\": args[0]})\n\n    if any(i in RESERVED_KWARGS for i in kwargs):\n        raise ValueError(\n            \"A reserved kwarg was passed ({}). Please remove it \"\n            \"and try again.\".format(RESERVED_KWARGS)\n        )\n    limit = kwargs.pop(\"limit\") if \"limit\" in kwargs else 0\n    offset = kwargs.pop(\"offset\") if \"offset\" in kwargs else None\n    strict_filters = (\n        # kwargs value takes precedence on globally set value\n        kwargs.pop(\"strict_filters\")\n        if \"strict_filters\" in kwargs\n        else self.api.strict_filters\n    )\n\n    if limit == 0 and offset is not None:\n        raise ValueError(\"offset requires a positive limit value\")\n    filters = {x: y if y is not None else \"null\" for x, y in kwargs.items()}\n\n    if strict_filters:\n        self._validate_openapi_parameters(\"get\", filters)\n\n    req = Request(\n        filters=filters,\n        base=self.url,\n        token=self.token,\n        http_session=self.api.http_session,\n        threading=self.api.threading,\n        limit=limit,\n        offset=offset,\n    )\n\n    return RecordSet(self, req)\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.get","title":"<code>get(self, *args, **kwargs)</code>","text":"<p>Queries the DetailsView of a given endpoint.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.get--parameters","title":"Parameters","text":"<ul> <li>key (int, optional): id for the item to be retrieved.</li> <li>kwargs: Accepts the same keyword args as filter(). Any search argument the endpoint accepts can     be added as a keyword arg.</li> <li>strict_filters (bool, optional): Overrides the global filter     validation per-request basis. Handled by the filter() method.</li> </ul>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.get--returns","title":"Returns","text":"<p>A single Record object or None</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.get--raises","title":"Raises","text":"<p>ValueError: if kwarg search return more than one value.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.get--examples","title":"Examples","text":"<p>Referencing with a kwarg that only returns one value:</p> <pre><code>nb.dcim.devices.get(name='test1-a3-tor1b')\n# test1-a3-tor1b\n</code></pre> <p>Referencing with an id:</p> <pre><code>nb.dcim.devices.get(1)\n# test1-edge1\n</code></pre> <p>Using multiple named arguments. For example, retrieving the location when the location name is not unique and used in multiple sites:</p> <pre><code>nb.locations.get(site='site-1', name='Row 1')\n# Row 1\n</code></pre> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>def get(self, *args, **kwargs):\n    \"\"\"Queries the DetailsView of a given endpoint.\n\n    ## Parameters\n\n    * **key** (int, optional): id for the item to be retrieved.\n    * **kwargs**: Accepts the same keyword args as filter(). Any search argument the endpoint accepts can\n        be added as a keyword arg.\n    * **strict_filters** (bool, optional): Overrides the global filter\n        validation per-request basis. Handled by the filter() method.\n\n    ## Returns\n    A single Record object or None\n\n    ## Raises\n    ValueError: if kwarg search return more than one value.\n\n    ## Examples\n\n    Referencing with a kwarg that only returns one value:\n\n    ```python\n    nb.dcim.devices.get(name='test1-a3-tor1b')\n    # test1-a3-tor1b\n    ```\n\n    Referencing with an id:\n\n    ```python\n    nb.dcim.devices.get(1)\n    # test1-edge1\n    ```\n\n    Using multiple named arguments. For example, retrieving the location when the location name is not unique and used in multiple sites:\n\n    ```python\n    nb.locations.get(site='site-1', name='Row 1')\n    # Row 1\n    ```\n    \"\"\"\n    try:\n        key = args[0]\n    except IndexError:\n        key = None\n\n    if not key:\n        resp = self.filter(**kwargs)\n        ret = next(resp, None)\n        if not ret:\n            return ret\n        try:\n            next(resp)\n            raise ValueError(\n                \"get() returned more than one result. \"\n                \"Check that the kwarg(s) passed are valid for this \"\n                \"endpoint or use filter() or all() instead.\"\n            )\n        except StopIteration:\n            return ret\n\n    req = Request(\n        key=key,\n        base=self.url,\n        token=self.token,\n        http_session=self.api.http_session,\n    )\n    try:\n        return next(RecordSet(self, req), None)\n    except RequestError as e:\n        if e.req.status_code == 404:\n            return None\n        else:\n            raise e\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.update","title":"<code>update(self, objects)</code>","text":"<p>Updates objects in NetBox.</p> <p>Takes a list of objects and updates them in NetBox.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.update--parameters","title":"Parameters","text":"<ul> <li>objects (list): A list of Record objects to update.</li> </ul>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.update--returns","title":"Returns","text":"<p>A list of Record objects.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.Endpoint.update--examples","title":"Examples","text":"<pre><code>devices = nb.dcim.devices.filter(site='test1')\nfor device in devices:\n    device.status = 'active'\nnb.dcim.devices.update(devices)\n</code></pre> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>def update(self, objects):\n    \"\"\"Updates objects in NetBox.\n\n    Takes a list of objects and updates them in NetBox.\n\n    ## Parameters\n\n    * **objects** (list): A list of Record objects to update.\n\n    ## Returns\n    A list of Record objects.\n\n    ## Examples\n\n    ```python\n    devices = nb.dcim.devices.filter(site='test1')\n    for device in devices:\n        device.status = 'active'\n    nb.dcim.devices.update(devices)\n    ```\n    \"\"\"\n    series = []\n    if not isinstance(objects, list):\n        raise ValueError(\n            \"Objects passed must be list[dict|Record] - was {}\".format(\n                type(objects)\n            )\n        )\n    for o in objects:\n        if isinstance(o, Record):\n            data = o.updates()\n            if data:\n                data[\"id\"] = o.id\n                series.append(data)\n        elif isinstance(o, dict):\n            if \"id\" not in o:\n                raise ValueError(\"id is missing from object: \" + str(o))\n            series.append(o)\n        else:\n            raise ValueError(\n                \"Object passed must be dict|Record - was {}\".format(type(objects))\n            )\n    req = Request(\n        base=self.url,\n        token=self.token,\n        http_session=self.api.http_session,\n    ).patch(series)\n\n    if isinstance(req, list):\n        return [self.return_obj(i, self.api, self) for i in req]\n    return self.return_obj(req, self.api, self)\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.DetailEndpoint","title":"<code> pynetbox.core.endpoint.DetailEndpoint        </code>","text":"<p>Enables read/write operations on detail endpoints.</p> <p>Endpoints like <code>available-ips</code> that are detail routes off traditional endpoints are handled with this class.</p> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>class DetailEndpoint:\n    \"\"\"Enables read/write operations on detail endpoints.\n\n    Endpoints like `available-ips` that are detail routes off\n    traditional endpoints are handled with this class.\n    \"\"\"\n\n    def __init__(self, parent_obj, name, custom_return=None):\n        self.parent_obj = parent_obj\n        self.custom_return = custom_return\n        self.url = \"{}/{}/{}/\".format(parent_obj.endpoint.url, parent_obj.id, name)\n        self.request_kwargs = dict(\n            base=self.url,\n            token=parent_obj.api.token,\n            http_session=parent_obj.api.http_session,\n        )\n\n    def list(self, **kwargs):\n        \"\"\"The view operation for a detail endpoint.\n\n        Returns the response from NetBox for a detail endpoint.\n\n        ## Parameters\n\n        * **kwargs**: Key/value pairs that get converted into URL\n            parameters when passed to the endpoint.\n            E.g. `.list(method='get_facts')` would be converted to\n            `.../?method=get_facts`.\n\n        ## Returns\n        A Record object or list of Record objects created\n        from data retrieved from NetBox.\n        \"\"\"\n        req = Request(**self.request_kwargs).get(add_params=kwargs)\n\n        if self.custom_return:\n            return [\n                self.custom_return(\n                    i, self.parent_obj.endpoint.api, self.parent_obj.endpoint\n                )\n                for i in req\n            ]\n        return req\n\n    def create(self, data=None):\n        \"\"\"The write operation for a detail endpoint.\n\n        Creates objects on a detail endpoint in NetBox.\n\n        ## Parameters\n\n        * **data** (dict/list, optional): A dictionary containing the\n            key/value pair of the items you're creating on the parent\n            object. Defaults to empty dict which will create a single\n            item with default values.\n\n        ## Returns\n        A Record object or list of Record objects created\n        from data created in NetBox.\n        \"\"\"\n        data = data or {}\n        req = Request(**self.request_kwargs).post(data)\n        if self.custom_return:\n            if isinstance(req, list):\n                return [\n                    self.custom_return(\n                        req_item, self.parent_obj.endpoint.api, self.parent_obj.endpoint\n                    )\n                    for req_item in req\n                ]\n            else:\n                return self.custom_return(\n                    req, self.parent_obj.endpoint.api, self.parent_obj.endpoint\n                )\n        return req\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.DetailEndpoint.create","title":"<code>create(self, data=None)</code>","text":"<p>The write operation for a detail endpoint.</p> <p>Creates objects on a detail endpoint in NetBox.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.DetailEndpoint.create--parameters","title":"Parameters","text":"<ul> <li>data (dict/list, optional): A dictionary containing the     key/value pair of the items you're creating on the parent     object. Defaults to empty dict which will create a single     item with default values.</li> </ul>"},{"location":"endpoint/#pynetbox.core.endpoint.DetailEndpoint.create--returns","title":"Returns","text":"<p>A Record object or list of Record objects created from data created in NetBox.</p> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>def create(self, data=None):\n    \"\"\"The write operation for a detail endpoint.\n\n    Creates objects on a detail endpoint in NetBox.\n\n    ## Parameters\n\n    * **data** (dict/list, optional): A dictionary containing the\n        key/value pair of the items you're creating on the parent\n        object. Defaults to empty dict which will create a single\n        item with default values.\n\n    ## Returns\n    A Record object or list of Record objects created\n    from data created in NetBox.\n    \"\"\"\n    data = data or {}\n    req = Request(**self.request_kwargs).post(data)\n    if self.custom_return:\n        if isinstance(req, list):\n            return [\n                self.custom_return(\n                    req_item, self.parent_obj.endpoint.api, self.parent_obj.endpoint\n                )\n                for req_item in req\n            ]\n        else:\n            return self.custom_return(\n                req, self.parent_obj.endpoint.api, self.parent_obj.endpoint\n            )\n    return req\n</code></pre>"},{"location":"endpoint/#pynetbox.core.endpoint.DetailEndpoint.list","title":"<code>list(self, **kwargs)</code>","text":"<p>The view operation for a detail endpoint.</p> <p>Returns the response from NetBox for a detail endpoint.</p>"},{"location":"endpoint/#pynetbox.core.endpoint.DetailEndpoint.list--parameters","title":"Parameters","text":"<ul> <li>kwargs: Key/value pairs that get converted into URL     parameters when passed to the endpoint.     E.g. <code>.list(method='get_facts')</code> would be converted to     <code>.../?method=get_facts</code>.</li> </ul>"},{"location":"endpoint/#pynetbox.core.endpoint.DetailEndpoint.list--returns","title":"Returns","text":"<p>A Record object or list of Record objects created from data retrieved from NetBox.</p> Source code in <code>pynetbox/core/endpoint.py</code> <pre><code>def list(self, **kwargs):\n    \"\"\"The view operation for a detail endpoint.\n\n    Returns the response from NetBox for a detail endpoint.\n\n    ## Parameters\n\n    * **kwargs**: Key/value pairs that get converted into URL\n        parameters when passed to the endpoint.\n        E.g. `.list(method='get_facts')` would be converted to\n        `.../?method=get_facts`.\n\n    ## Returns\n    A Record object or list of Record objects created\n    from data retrieved from NetBox.\n    \"\"\"\n    req = Request(**self.request_kwargs).get(add_params=kwargs)\n\n    if self.custom_return:\n        return [\n            self.custom_return(\n                i, self.parent_obj.endpoint.api, self.parent_obj.endpoint\n            )\n            for i in req\n        ]\n    return req\n</code></pre>"},{"location":"request/","title":"Request","text":""},{"location":"request/#pynetbox.core.query.RequestError","title":"<code> pynetbox.core.query.RequestError            (Exception)         </code>","text":"<p>Basic Request Exception.</p> <p>More detailed exception that returns the original requests object for inspection. Along with some attributes with specific details from the requests object. If return is json we decode and add it to the message.</p>"},{"location":"request/#pynetbox.core.query.RequestError--examples","title":"Examples","text":"<pre><code>try:\n    nb.dcim.devices.create(name=\"destined-for-failure\")\nexcept pynetbox.RequestError as e:\n    print(e.error)\n</code></pre> Source code in <code>pynetbox/core/query.py</code> <pre><code>class RequestError(Exception):\n    \"\"\"Basic Request Exception.\n\n    More detailed exception that returns the original requests object\n    for inspection. Along with some attributes with specific details\n    from the requests object. If return is json we decode and add it\n    to the message.\n\n    ## Examples\n\n    ```python\n    try:\n        nb.dcim.devices.create(name=\"destined-for-failure\")\n    except pynetbox.RequestError as e:\n        print(e.error)\n    ```\n    \"\"\"\n\n    def __init__(self, req):\n        if req.status_code == 404:\n            self.message = \"The requested url: {} could not be found.\".format(req.url)\n        else:\n            try:\n                self.message = \"The request failed with code {} {}: {}\".format(\n                    req.status_code, req.reason, req.json()\n                )\n            except ValueError:\n                self.message = (\n                    \"The request failed with code {} {} but more specific \"\n                    \"details were not returned in json. Check the NetBox Logs \"\n                    \"or investigate this exception's error attribute.\".format(\n                        req.status_code, req.reason\n                    )\n                )\n\n        super().__init__(self.message)\n        self.req = req\n        self.request_body = req.request.body\n        self.base = req.url\n        self.error = req.text\n\n    def __str__(self):\n        return self.message\n</code></pre>"},{"location":"request/#pynetbox.core.query.ContentError","title":"<code> pynetbox.core.query.ContentError            (Exception)         </code>","text":"<p>Content Exception.</p> <p>If the API URL does not point to a valid NetBox API, the server may return a valid response code, but the content is not json. This exception is raised in those cases.</p> Source code in <code>pynetbox/core/query.py</code> <pre><code>class ContentError(Exception):\n    \"\"\"Content Exception.\n\n    If the API URL does not point to a valid NetBox API, the server may\n    return a valid response code, but the content is not json. This\n    exception is raised in those cases.\n    \"\"\"\n\n    def __init__(self, req):\n        super().__init__(req)\n        self.req = req\n        self.request_body = req.request.body\n        self.base = req.url\n        self.error = (\n            \"The server returned invalid (non-json) data. Maybe not a NetBox server?\"\n        )\n\n    def __str__(self):\n        return self.error\n</code></pre>"},{"location":"request/#pynetbox.core.query.AllocationError","title":"<code> pynetbox.core.query.AllocationError            (Exception)         </code>","text":"<p>Allocation Exception.</p> <p>Used with available-ips/available-prefixes when there is no room for allocation and NetBox returns 409 Conflict.</p> Source code in <code>pynetbox/core/query.py</code> <pre><code>class AllocationError(Exception):\n    \"\"\"Allocation Exception.\n\n    Used with available-ips/available-prefixes when there is no\n    room for allocation and NetBox returns 409 Conflict.\n    \"\"\"\n\n    def __init__(self, req):\n        super().__init__(req)\n        self.req = req\n        self.request_body = req.request.body\n        self.base = req.url\n        self.error = \"The requested allocation could not be fulfilled.\"\n\n    def __str__(self):\n        return self.error\n</code></pre>"},{"location":"response/","title":"Response","text":""},{"location":"response/#pynetbox.core.response.Record","title":"<code> pynetbox.core.response.Record        </code>","text":"<p>Create Python objects from NetBox API responses.</p> <p>Creates an object from a NetBox response passed as <code>values</code>. Nested dicts that represent other endpoints are also turned into Record objects. All fields are then assigned to the object's attributes. If a missing attr is requested (e.g. requesting a field that's only present on a full response on a Record made from a nested response) then pynetbox will make a request for the full object and return the requested value.</p>"},{"location":"response/#pynetbox.core.response.Record--examples","title":"Examples","text":"<p>Default representation of the object is usually its name:</p> <pre><code>x = nb.dcim.devices.get(1)\nx\n# test1-switch1\n</code></pre> <p>Querying a string field:</p> <pre><code>x = nb.dcim.devices.get(1)\nx.serial\n# 'ABC123'\n</code></pre> <p>Querying a field on a nested object:</p> <pre><code>x = nb.dcim.devices.get(1)\nx.device_type.model\n# 'QFX5100-24Q'\n</code></pre> <p>Casting the object as a dictionary:</p> <pre><code>from pprint import pprint\npprint(dict(x))\n{\n    'asset_tag': None,\n    'cluster': None,\n    'comments': '',\n    'config_context': {},\n    'created': '2018-04-01',\n    'custom_fields': {},\n    'role': {\n        'id': 1,\n        'name': 'Test Switch',\n        'slug': 'test-switch',\n        'url': 'http://localhost:8000/api/dcim/device-roles/1/'\n    },\n    'device_type': {...},\n    'display_name': 'test1-switch1',\n    'face': {'label': 'Rear', 'value': 1},\n    'id': 1,\n    'name': 'test1-switch1',\n    'parent_device': None,\n    'platform': {...},\n    'position': 1,\n    'primary_ip': {\n        'address': '192.0.2.1/24',\n        'family': 4,\n        'id': 1,\n        'url': 'http://localhost:8000/api/ipam/ip-addresses/1/'\n    },\n    'primary_ip4': {...},\n    'primary_ip6': None,\n    'rack': {\n        'display_name': 'Test Rack',\n        'id': 1,\n        'name': 'Test Rack',\n        'url': 'http://localhost:8000/api/dcim/racks/1/'\n    },\n    'site': {\n        'id': 1,\n        'name': 'TEST',\n        'slug': 'TEST',\n        'url': 'http://localhost:8000/api/dcim/sites/1/'\n    },\n    'status': {'label': 'Active', 'value': 1},\n    'tags': [],\n    'tenant': None,\n    'vc_position': None,\n    'vc_priority': None,\n    'virtual_chassis': None\n}\n</code></pre> <p>Iterating over a Record object:</p> <pre><code>for i in x:\n    print(i)\n\n# ('id', 1)\n# ('name', 'test1-switch1')\n# ('display_name', 'test1-switch1')\n</code></pre> Source code in <code>pynetbox/core/response.py</code> <pre><code>class Record:\n    \"\"\"Create Python objects from NetBox API responses.\n\n    Creates an object from a NetBox response passed as `values`.\n    Nested dicts that represent other endpoints are also turned\n    into Record objects. All fields are then assigned to the\n    object's attributes. If a missing attr is requested\n    (e.g. requesting a field that's only present on a full response on\n    a Record made from a nested response) then pynetbox will make a\n    request for the full object and return the requested value.\n\n    ## Examples\n\n    Default representation of the object is usually its name:\n\n    ```python\n    x = nb.dcim.devices.get(1)\n    x\n    # test1-switch1\n    ```\n\n    Querying a string field:\n\n    ```python\n    x = nb.dcim.devices.get(1)\n    x.serial\n    # 'ABC123'\n    ```\n\n    Querying a field on a nested object:\n\n    ```python\n    x = nb.dcim.devices.get(1)\n    x.device_type.model\n    # 'QFX5100-24Q'\n    ```\n\n    Casting the object as a dictionary:\n\n    ```python\n    from pprint import pprint\n    pprint(dict(x))\n    {\n        'asset_tag': None,\n        'cluster': None,\n        'comments': '',\n        'config_context': {},\n        'created': '2018-04-01',\n        'custom_fields': {},\n        'role': {\n            'id': 1,\n            'name': 'Test Switch',\n            'slug': 'test-switch',\n            'url': 'http://localhost:8000/api/dcim/device-roles/1/'\n        },\n        'device_type': {...},\n        'display_name': 'test1-switch1',\n        'face': {'label': 'Rear', 'value': 1},\n        'id': 1,\n        'name': 'test1-switch1',\n        'parent_device': None,\n        'platform': {...},\n        'position': 1,\n        'primary_ip': {\n            'address': '192.0.2.1/24',\n            'family': 4,\n            'id': 1,\n            'url': 'http://localhost:8000/api/ipam/ip-addresses/1/'\n        },\n        'primary_ip4': {...},\n        'primary_ip6': None,\n        'rack': {\n            'display_name': 'Test Rack',\n            'id': 1,\n            'name': 'Test Rack',\n            'url': 'http://localhost:8000/api/dcim/racks/1/'\n        },\n        'site': {\n            'id': 1,\n            'name': 'TEST',\n            'slug': 'TEST',\n            'url': 'http://localhost:8000/api/dcim/sites/1/'\n        },\n        'status': {'label': 'Active', 'value': 1},\n        'tags': [],\n        'tenant': None,\n        'vc_position': None,\n        'vc_priority': None,\n        'virtual_chassis': None\n    }\n    ```\n\n    Iterating over a Record object:\n\n    ```python\n    for i in x:\n        print(i)\n\n    # ('id', 1)\n    # ('name', 'test1-switch1')\n    # ('display_name', 'test1-switch1')\n    ```\n    \"\"\"\n\n    url = None\n\n    def __init__(self, values, api, endpoint):\n        self.has_details = False\n        self._full_cache = []\n        self._init_cache = []\n        self.api = api\n        self.default_ret = Record\n        self.endpoint = (\n            self._endpoint_from_url(values[\"url\"])\n            if values and \"url\" in values and values[\"url\"]\n            else endpoint\n        )\n        if values:\n            self._parse_values(values)\n\n    def __getattr__(self, k):\n        \"\"\"Default behavior for missing attrs.\n\n        We'll call `full_details()` if we're asked for an attribute\n        we don't have.\n\n        In order to prevent non-explicit behavior,`k='keys'` is\n        excluded because casting to dict() calls this attr.\n        \"\"\"\n        if self.url:\n            if self.has_details is False and k != \"keys\":\n                if self.full_details():\n                    ret = getattr(self, k, None)\n                    if ret or hasattr(self, k):\n                        return ret\n\n        raise AttributeError('object has no attribute \"{}\"'.format(k))\n\n    def __iter__(self):\n        for i in dict(self._init_cache):\n            cur_attr = getattr(self, i)\n            if isinstance(cur_attr, Record):\n                yield i, dict(cur_attr)\n            elif isinstance(cur_attr, list) and all(\n                isinstance(i, (Record, GenericListObject)) for i in cur_attr\n            ):\n                yield i, [dict(x) for x in cur_attr]\n            else:\n                yield i, cur_attr\n\n    def __getitem__(self, k):\n        return dict(self)[k]\n\n    def __str__(self):\n        return (\n            getattr(self, \"name\", None)\n            or getattr(self, \"label\", None)\n            or getattr(self, \"display\", None)\n            or \"\"\n        )\n\n    def __repr__(self):\n        return str(self)\n\n    def __getstate__(self):\n        return self.__dict__\n\n    def __setstate__(self, d):\n        self.__dict__.update(d)\n\n    def __key__(self):\n        if hasattr(self, \"id\"):\n            return (self.endpoint.name, self.id)\n        else:\n            return self.endpoint.name\n\n    def __hash__(self):\n        return hash(self.__key__())\n\n    def __eq__(self, other):\n        if isinstance(other, Record):\n            return self.__key__() == other.__key__()\n        return NotImplemented\n\n    def _add_cache(self, item):\n        key, value = item\n        self._init_cache.append((key, get_return(value)))\n\n    def _parse_values(self, values):\n        \"\"\"Parses values init arg.\n\n        Parses values dict at init and sets object attributes with the\n        values within.\n        \"\"\"\n\n        def generic_list_parser(key_name, list_item):\n            from pynetbox.models.mapper import CONTENT_TYPE_MAPPER\n\n            if (\n                isinstance(list_item, dict)\n                and \"object_type\" in list_item\n                and \"object\" in list_item\n            ):\n                lookup = list_item[\"object_type\"]\n                if model := CONTENT_TYPE_MAPPER.get(lookup, None):\n                    record = model(list_item[\"object\"], self.api, self.endpoint)\n                    return GenericListObject(record)\n\n            return list_item\n\n        def list_parser(key_name, list_item):\n            if isinstance(list_item, dict):\n                lookup = getattr(self.__class__, key_name, None)\n                if not isinstance(lookup, list):\n                    # This is *list_parser*, so if the custom model field is not\n                    # a list (or is not defined), just return the default model\n                    return self.default_ret(list_item, self.api, self.endpoint)\n                else:\n                    model = lookup[0]\n                    return model(list_item, self.api, self.endpoint)\n\n            return list_item\n\n        for k, v in values.items():\n            if isinstance(v, dict):\n                lookup = getattr(self.__class__, k, None)\n                if k in [\"custom_fields\", \"local_context_data\"] or hasattr(\n                    lookup, \"_json_field\"\n                ):\n                    self._add_cache((k, copy.deepcopy(v)))\n                    setattr(self, k, v)\n                    continue\n                if lookup:\n                    v = lookup(v, self.api, self.endpoint)\n                else:\n                    v = self.default_ret(v, self.api, self.endpoint)\n                self._add_cache((k, v))\n\n            elif isinstance(v, list):\n                # check if GFK\n                if len(v) and isinstance(v[0], dict) and \"object_type\" in v[0]:\n                    v = [generic_list_parser(k, i) for i in v]\n                    to_cache = [i.serialize() for i in v]\n                elif k == \"constraints\":\n                    # Permissions constraints can be either dict or list\n                    to_cache = copy.deepcopy(v)\n                else:\n                    v = [list_parser(k, i) for i in v]\n                    to_cache = list(v)\n                self._add_cache((k, to_cache))\n\n            else:\n                self._add_cache((k, v))\n            setattr(self, k, v)\n\n    def _endpoint_from_url(self, url):\n        url_path = urlsplit(url).path\n        base_url_path_parts = urlsplit(self.api.base_url).path.split(\"/\")\n        if len(base_url_path_parts) &gt; 2:\n            # There are some extra directories in the path, remove them from url\n            extra_path = \"/\".join(base_url_path_parts[:-1])\n            url_path = url_path[len(extra_path) :]\n        split_url_path = url_path.split(\"/\")\n        if split_url_path[2] == \"plugins\":\n            app = \"plugins/{}\".format(split_url_path[3])\n            name = split_url_path[4]\n        else:\n            app, name = split_url_path[2:4]\n        return getattr(pynetbox.core.app.App(self.api, app), name)\n\n    def full_details(self):\n        \"\"\"Queries the hyperlinked endpoint if 'url' is defined.\n\n        This method will populate the attributes from the detail\n        endpoint when it's called. Sets the class-level `has_details`\n        attribute when it's called to prevent being called more\n        than once.\n\n        :returns: True\n        \"\"\"\n        if self.url:\n            req = Request(\n                base=self.url,\n                token=self.api.token,\n                http_session=self.api.http_session,\n            )\n            self._parse_values(next(req.get()))\n            self.has_details = True\n            return True\n        return False\n\n    def serialize(self, nested=False, init=False):\n        \"\"\"Serializes an object\n\n        Pulls all the attributes in an object and creates a dict that\n        can be turned into the json that netbox is expecting.\n\n        If an attribute's value is a ``Record`` type it's replaced with\n        the ``id`` field of that object.\n\n\n        .. note::\n\n            Using this to get a dictionary representation of the record\n            is discouraged. It's probably better to cast to dict()\n            instead. See Record docstring for example.\n\n        :returns: dict.\n        \"\"\"\n        if nested:\n            return get_return(self)\n\n        if init:\n            init_vals = dict(self._init_cache)\n\n        ret = {}\n\n        for i in dict(self):\n            current_val = getattr(self, i) if not init else init_vals.get(i)\n            if i == \"custom_fields\":\n                ret[i] = flatten_custom(current_val)\n            else:\n                if isinstance(current_val, Record):\n                    current_val = getattr(current_val, \"serialize\")(nested=True)\n\n                if isinstance(current_val, list):\n                    serialized_list = []\n                    for v in current_val:\n                        if isinstance(v, GenericListObject):\n                            v = v.serialize()\n                        elif isinstance(v, Record):\n                            v = v.id\n                        serialized_list.append(v)\n                    current_val = serialized_list\n                    if i in LIST_AS_SET and (\n                        all([isinstance(v, str) for v in current_val])\n                        or all([isinstance(v, int) for v in current_val])\n                    ):\n                        current_val = list(OrderedDict.fromkeys(current_val))\n                ret[i] = current_val\n\n        return ret\n\n    def _diff(self):\n        def fmt_dict(k, v):\n            if isinstance(v, dict):\n                return k, Hashabledict(v)\n            if isinstance(v, list):\n                return k, \",\".join(map(str, v))\n            return k, v\n\n        current = Hashabledict({fmt_dict(k, v) for k, v in self.serialize().items()})\n        init = Hashabledict(\n            {fmt_dict(k, v) for k, v in self.serialize(init=True).items()}\n        )\n        return set([i[0] for i in set(current.items()) ^ set(init.items())])\n\n    def updates(self):\n        \"\"\"Compiles changes for an existing object into a dict.\n\n        Takes a diff between the objects current state and its state at init\n        and returns them as a dictionary, which will be empty if no changes.\n\n        :returns: dict.\n        :example:\n\n        &gt;&gt;&gt; x = nb.dcim.devices.get(name='test1-a3-tor1b')\n        &gt;&gt;&gt; x.serial\n        ''\n        &gt;&gt;&gt; x.serial = '1234'\n        &gt;&gt;&gt; x.updates()\n        {'serial': '1234'}\n        &gt;&gt;&gt;\n        \"\"\"\n        if self.id:\n            diff = self._diff()\n            if diff:\n                serialized = self.serialize()\n                return {i: serialized[i] for i in diff}\n        return {}\n\n    def save(self):\n        \"\"\"Saves changes to an existing object.\n\n        Takes a diff between the objects current state and its state at init\n        and sends them as a dictionary to Request.patch().\n\n        :returns: True if PATCH request was successful.\n        :example:\n\n        &gt;&gt;&gt; x = nb.dcim.devices.get(name='test1-a3-tor1b')\n        &gt;&gt;&gt; x.serial\n        ''\n        &gt;&gt;&gt; x.serial = '1234'\n        &gt;&gt;&gt; x.save()\n        True\n        &gt;&gt;&gt;\n        \"\"\"\n        updates = self.updates()\n        if updates:\n            req = Request(\n                key=self.id,\n                base=self.endpoint.url,\n                token=self.api.token,\n                http_session=self.api.http_session,\n            )\n            if req.patch(updates):\n                return True\n        return False\n\n    def update(self, data):\n        \"\"\"Update an object with a dictionary.\n\n        Accepts a dict and uses it to update the record and call save().\n        For nested and choice fields you'd pass an int the same as\n        if you were modifying the attribute and calling save().\n\n        :arg dict data: Dictionary containing the k/v to update the\n            record object with.\n        :returns: True if PATCH request was successful.\n        :example:\n\n        &gt;&gt;&gt; x = nb.dcim.devices.get(1)\n        &gt;&gt;&gt; x.update({\n        ...   \"name\": \"test-switch2\",\n        ...   \"serial\": \"ABC321\",\n        ... })\n        True\n\n        \"\"\"\n\n        for k, v in data.items():\n            setattr(self, k, v)\n        return self.save()\n\n    def delete(self):\n        \"\"\"Deletes an existing object.\n\n        :returns: True if DELETE operation was successful.\n        :example:\n\n        &gt;&gt;&gt; x = nb.dcim.devices.get(name='test1-a3-tor1b')\n        &gt;&gt;&gt; x.delete()\n        True\n        &gt;&gt;&gt;\n        \"\"\"\n        req = Request(\n            key=self.id,\n            base=self.endpoint.url,\n            token=self.api.token,\n            http_session=self.api.http_session,\n        )\n        return True if req.delete() else False\n</code></pre>"},{"location":"response/#pynetbox.core.response.Record.delete","title":"<code>delete(self)</code>","text":"<p>Deletes an existing object.</p> <p>:returns: True if DELETE operation was successful. :example:</p> <p>x = nb.dcim.devices.get(name='test1-a3-tor1b') x.delete() True </p> Source code in <code>pynetbox/core/response.py</code> <pre><code>def delete(self):\n    \"\"\"Deletes an existing object.\n\n    :returns: True if DELETE operation was successful.\n    :example:\n\n    &gt;&gt;&gt; x = nb.dcim.devices.get(name='test1-a3-tor1b')\n    &gt;&gt;&gt; x.delete()\n    True\n    &gt;&gt;&gt;\n    \"\"\"\n    req = Request(\n        key=self.id,\n        base=self.endpoint.url,\n        token=self.api.token,\n        http_session=self.api.http_session,\n    )\n    return True if req.delete() else False\n</code></pre>"},{"location":"response/#pynetbox.core.response.Record.full_details","title":"<code>full_details(self)</code>","text":"<p>Queries the hyperlinked endpoint if 'url' is defined.</p> <p>This method will populate the attributes from the detail endpoint when it's called. Sets the class-level <code>has_details</code> attribute when it's called to prevent being called more than once.</p> <p>:returns: True</p> Source code in <code>pynetbox/core/response.py</code> <pre><code>def full_details(self):\n    \"\"\"Queries the hyperlinked endpoint if 'url' is defined.\n\n    This method will populate the attributes from the detail\n    endpoint when it's called. Sets the class-level `has_details`\n    attribute when it's called to prevent being called more\n    than once.\n\n    :returns: True\n    \"\"\"\n    if self.url:\n        req = Request(\n            base=self.url,\n            token=self.api.token,\n            http_session=self.api.http_session,\n        )\n        self._parse_values(next(req.get()))\n        self.has_details = True\n        return True\n    return False\n</code></pre>"},{"location":"response/#pynetbox.core.response.Record.save","title":"<code>save(self)</code>","text":"<p>Saves changes to an existing object.</p> <p>Takes a diff between the objects current state and its state at init and sends them as a dictionary to Request.patch().</p> <p>:returns: True if PATCH request was successful. :example:</p> <p>x = nb.dcim.devices.get(name='test1-a3-tor1b') x.serial '' x.serial = '1234' x.save() True </p> Source code in <code>pynetbox/core/response.py</code> <pre><code>def save(self):\n    \"\"\"Saves changes to an existing object.\n\n    Takes a diff between the objects current state and its state at init\n    and sends them as a dictionary to Request.patch().\n\n    :returns: True if PATCH request was successful.\n    :example:\n\n    &gt;&gt;&gt; x = nb.dcim.devices.get(name='test1-a3-tor1b')\n    &gt;&gt;&gt; x.serial\n    ''\n    &gt;&gt;&gt; x.serial = '1234'\n    &gt;&gt;&gt; x.save()\n    True\n    &gt;&gt;&gt;\n    \"\"\"\n    updates = self.updates()\n    if updates:\n        req = Request(\n            key=self.id,\n            base=self.endpoint.url,\n            token=self.api.token,\n            http_session=self.api.http_session,\n        )\n        if req.patch(updates):\n            return True\n    return False\n</code></pre>"},{"location":"response/#pynetbox.core.response.Record.serialize","title":"<code>serialize(self, nested=False, init=False)</code>","text":"<p>Serializes an object</p> <p>Pulls all the attributes in an object and creates a dict that can be turned into the json that netbox is expecting.</p> <p>If an attribute's value is a <code>Record</code> type it's replaced with the <code>id</code> field of that object.</p> <p>.. note::</p> <pre><code>Using this to get a dictionary representation of the record\nis discouraged. It's probably better to cast to dict()\ninstead. See Record docstring for example.\n</code></pre> <p>:returns: dict.</p> Source code in <code>pynetbox/core/response.py</code> <pre><code>def serialize(self, nested=False, init=False):\n    \"\"\"Serializes an object\n\n    Pulls all the attributes in an object and creates a dict that\n    can be turned into the json that netbox is expecting.\n\n    If an attribute's value is a ``Record`` type it's replaced with\n    the ``id`` field of that object.\n\n\n    .. note::\n\n        Using this to get a dictionary representation of the record\n        is discouraged. It's probably better to cast to dict()\n        instead. See Record docstring for example.\n\n    :returns: dict.\n    \"\"\"\n    if nested:\n        return get_return(self)\n\n    if init:\n        init_vals = dict(self._init_cache)\n\n    ret = {}\n\n    for i in dict(self):\n        current_val = getattr(self, i) if not init else init_vals.get(i)\n        if i == \"custom_fields\":\n            ret[i] = flatten_custom(current_val)\n        else:\n            if isinstance(current_val, Record):\n                current_val = getattr(current_val, \"serialize\")(nested=True)\n\n            if isinstance(current_val, list):\n                serialized_list = []\n                for v in current_val:\n                    if isinstance(v, GenericListObject):\n                        v = v.serialize()\n                    elif isinstance(v, Record):\n                        v = v.id\n                    serialized_list.append(v)\n                current_val = serialized_list\n                if i in LIST_AS_SET and (\n                    all([isinstance(v, str) for v in current_val])\n                    or all([isinstance(v, int) for v in current_val])\n                ):\n                    current_val = list(OrderedDict.fromkeys(current_val))\n            ret[i] = current_val\n\n    return ret\n</code></pre>"},{"location":"response/#pynetbox.core.response.Record.update","title":"<code>update(self, data)</code>","text":"<p>Update an object with a dictionary.</p> <p>Accepts a dict and uses it to update the record and call save(). For nested and choice fields you'd pass an int the same as if you were modifying the attribute and calling save().</p> <p>:arg dict data: Dictionary containing the k/v to update the     record object with. :returns: True if PATCH request was successful. :example:</p> <p>x = nb.dcim.devices.get(1) x.update({ ...   \"name\": \"test-switch2\", ...   \"serial\": \"ABC321\", ... }) True</p> Source code in <code>pynetbox/core/response.py</code> <pre><code>def update(self, data):\n    \"\"\"Update an object with a dictionary.\n\n    Accepts a dict and uses it to update the record and call save().\n    For nested and choice fields you'd pass an int the same as\n    if you were modifying the attribute and calling save().\n\n    :arg dict data: Dictionary containing the k/v to update the\n        record object with.\n    :returns: True if PATCH request was successful.\n    :example:\n\n    &gt;&gt;&gt; x = nb.dcim.devices.get(1)\n    &gt;&gt;&gt; x.update({\n    ...   \"name\": \"test-switch2\",\n    ...   \"serial\": \"ABC321\",\n    ... })\n    True\n\n    \"\"\"\n\n    for k, v in data.items():\n        setattr(self, k, v)\n    return self.save()\n</code></pre>"},{"location":"response/#pynetbox.core.response.Record.updates","title":"<code>updates(self)</code>","text":"<p>Compiles changes for an existing object into a dict.</p> <p>Takes a diff between the objects current state and its state at init and returns them as a dictionary, which will be empty if no changes.</p> <p>:returns: dict. :example:</p> <p>x = nb.dcim.devices.get(name='test1-a3-tor1b') x.serial '' x.serial = '1234' x.updates() {'serial': '1234'} </p> Source code in <code>pynetbox/core/response.py</code> <pre><code>def updates(self):\n    \"\"\"Compiles changes for an existing object into a dict.\n\n    Takes a diff between the objects current state and its state at init\n    and returns them as a dictionary, which will be empty if no changes.\n\n    :returns: dict.\n    :example:\n\n    &gt;&gt;&gt; x = nb.dcim.devices.get(name='test1-a3-tor1b')\n    &gt;&gt;&gt; x.serial\n    ''\n    &gt;&gt;&gt; x.serial = '1234'\n    &gt;&gt;&gt; x.updates()\n    {'serial': '1234'}\n    &gt;&gt;&gt;\n    \"\"\"\n    if self.id:\n        diff = self._diff()\n        if diff:\n            serialized = self.serialize()\n            return {i: serialized[i] for i in diff}\n    return {}\n</code></pre>"},{"location":"response/#pynetbox.core.response.RecordSet","title":"<code> pynetbox.core.response.RecordSet        </code>","text":"<p>Iterator containing Record objects.</p> <p>Returned by <code>Endpoint.all()</code> and <code>Endpoint.filter()</code> methods. Allows iteration of and actions to be taken on the results from the aforementioned methods. Contains Record objects.</p>"},{"location":"response/#pynetbox.core.response.RecordSet--examples","title":"Examples","text":"<p>To see how many results are in a query by calling <code>len()</code>:</p> <pre><code>x = nb.dcim.devices.all()\nlen(x)\n# 123\n</code></pre> <p>Simple iteration of the results:</p> <pre><code>devices = nb.dcim.devices.all()\nfor device in devices:\n    print(device.name)\n\n# test1-leaf1\n# test1-leaf2\n# test1-leaf3\n</code></pre> Source code in <code>pynetbox/core/response.py</code> <pre><code>class RecordSet:\n    \"\"\"Iterator containing Record objects.\n\n    Returned by `Endpoint.all()` and `Endpoint.filter()` methods.\n    Allows iteration of and actions to be taken on the results from the aforementioned\n    methods. Contains Record objects.\n\n    ## Examples\n\n    To see how many results are in a query by calling `len()`:\n\n    ```python\n    x = nb.dcim.devices.all()\n    len(x)\n    # 123\n    ```\n\n    Simple iteration of the results:\n\n    ```python\n    devices = nb.dcim.devices.all()\n    for device in devices:\n        print(device.name)\n\n    # test1-leaf1\n    # test1-leaf2\n    # test1-leaf3\n    ```\n    \"\"\"\n\n    def __init__(self, endpoint, request, **kwargs):\n        self.endpoint = endpoint\n        self.request = request\n        self.response = self.request.get()\n        self._response_cache = []\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self._response_cache:\n            return self.endpoint.return_obj(\n                self._response_cache.pop(), self.endpoint.api, self.endpoint\n            )\n        return self.endpoint.return_obj(\n            next(self.response), self.endpoint.api, self.endpoint\n        )\n\n    def __len__(self):\n        try:\n            return self.request.count\n        except AttributeError:\n            try:\n                self._response_cache.append(next(self.response))\n            except StopIteration:\n                return 0\n            return self.request.count\n\n    def update(self, **kwargs):\n        \"\"\"Updates kwargs onto all Records in the RecordSet and saves these.\n\n        Updates are only sent to the API if a value were changed, and only for\n        the Records which were changed.\n\n        ## Returns\n        True if the update succeeded, None if no update were required.\n\n        ## Examples\n\n        ```python\n        result = nb.dcim.devices.filter(site_id=1).update(status='active')\n        # True\n        ```\n        \"\"\"\n        updates = []\n        for record in self:\n            # Update each record and determine if anything was updated\n            for k, v in kwargs.items():\n                setattr(record, k, v)\n            record_updates = record.updates()\n            if record_updates:\n                # if updated, add the id to the dict and append to list of updates\n                record_updates[\"id\"] = record.id\n                updates.append(record_updates)\n        if updates:\n            return self.endpoint.update(updates)\n        else:\n            return None\n\n    def delete(self):\n        \"\"\"Bulk deletes objects in a RecordSet.\n\n        Allows for batch deletion of multiple objects in a RecordSet.\n\n        ## Returns\n        True if bulk DELETE operation was successful.\n\n        ## Examples\n\n        Deleting offline `devices` on site 1:\n\n        ```python\n        netbox.dcim.devices.filter(site_id=1, status=\"offline\").delete()\n        ```\n        \"\"\"\n        return self.endpoint.delete(self)\n</code></pre>"},{"location":"response/#pynetbox.core.response.RecordSet.delete","title":"<code>delete(self)</code>","text":"<p>Bulk deletes objects in a RecordSet.</p> <p>Allows for batch deletion of multiple objects in a RecordSet.</p>"},{"location":"response/#pynetbox.core.response.RecordSet.delete--returns","title":"Returns","text":"<p>True if bulk DELETE operation was successful.</p>"},{"location":"response/#pynetbox.core.response.RecordSet.delete--examples","title":"Examples","text":"<p>Deleting offline <code>devices</code> on site 1:</p> <pre><code>netbox.dcim.devices.filter(site_id=1, status=\"offline\").delete()\n</code></pre> Source code in <code>pynetbox/core/response.py</code> <pre><code>def delete(self):\n    \"\"\"Bulk deletes objects in a RecordSet.\n\n    Allows for batch deletion of multiple objects in a RecordSet.\n\n    ## Returns\n    True if bulk DELETE operation was successful.\n\n    ## Examples\n\n    Deleting offline `devices` on site 1:\n\n    ```python\n    netbox.dcim.devices.filter(site_id=1, status=\"offline\").delete()\n    ```\n    \"\"\"\n    return self.endpoint.delete(self)\n</code></pre>"},{"location":"response/#pynetbox.core.response.RecordSet.update","title":"<code>update(self, **kwargs)</code>","text":"<p>Updates kwargs onto all Records in the RecordSet and saves these.</p> <p>Updates are only sent to the API if a value were changed, and only for the Records which were changed.</p>"},{"location":"response/#pynetbox.core.response.RecordSet.update--returns","title":"Returns","text":"<p>True if the update succeeded, None if no update were required.</p>"},{"location":"response/#pynetbox.core.response.RecordSet.update--examples","title":"Examples","text":"<pre><code>result = nb.dcim.devices.filter(site_id=1).update(status='active')\n# True\n</code></pre> Source code in <code>pynetbox/core/response.py</code> <pre><code>def update(self, **kwargs):\n    \"\"\"Updates kwargs onto all Records in the RecordSet and saves these.\n\n    Updates are only sent to the API if a value were changed, and only for\n    the Records which were changed.\n\n    ## Returns\n    True if the update succeeded, None if no update were required.\n\n    ## Examples\n\n    ```python\n    result = nb.dcim.devices.filter(site_id=1).update(status='active')\n    # True\n    ```\n    \"\"\"\n    updates = []\n    for record in self:\n        # Update each record and determine if anything was updated\n        for k, v in kwargs.items():\n            setattr(record, k, v)\n        record_updates = record.updates()\n        if record_updates:\n            # if updated, add the id to the dict and append to list of updates\n            record_updates[\"id\"] = record.id\n            updates.append(record_updates)\n    if updates:\n        return self.endpoint.update(updates)\n    else:\n        return None\n</code></pre>"},{"location":"development/","title":"Development","text":"<p>Thanks for your interest in contributing to pynetbox! This introduction covers a few important things to know before you get started.</p>"},{"location":"development/#the-code","title":"The Code","text":"<p>pynetbox is maintained on GitHub. GitHub also serves as one of our primary discussion forums. While all the code and discussion is publicly accessible, you'll need to register for a free GitHub account to engage in participation. Most people begin by forking the pynetbox repository under their own GitHub account to begin working on the code.</p> <p>There are two permanent branches in the repository:</p> <ul> <li><code>master</code> - Active development for the upcoming patch release. Pull requests will typically be based on this branch unless they introduce breaking changes that must be deferred until the next major release.</li> <li><code>feature</code> - New feature work to be introduced in the next major release.</li> </ul> <p>pynetbox components are arranged into modules:</p> <ul> <li><code>core/</code> - Core functionality including API interaction, response handling, and query building</li> <li><code>models/</code> - Model definitions for different NetBox object types</li> <li><code>tests/</code> - Test suite including unit and integration tests</li> <li><code>docs/</code> - Documentation files</li> </ul>"},{"location":"development/#proposing-changes","title":"Proposing Changes","text":"<p>All substantial changes made to the code base are tracked using GitHub issues. Feature requests, bug reports, and similar proposals must all be filed as issues and approved by a maintainer before work begins. This ensures that all changes to the code base are properly documented for future reference.</p> <p>To submit a new feature request or bug report for pynetbox, select and complete the appropriate issue template. Once your issue has been approved, you're welcome to submit a pull request containing your proposed changes.</p> <p>Note</p> <p>Avoid starting work on a proposal before it has been accepted. Not all proposed changes will be accepted, and we'd hate for you to waste time working on code that might not make it into the project.</p>"},{"location":"development/#getting-help","title":"Getting Help","text":"<p>There are two primary forums for getting assistance with pynetbox development:</p> <ul> <li>GitHub discussions - The preferred forum for general discussion and support issues. Ideal for shaping a feature requests prior to submitting an issue.</li> <li>#netbox on NetDev Community Slack - Good for quick chats. Avoid any discussion that might need to be referenced later on, as the chat history is not retained indefinitely.</li> </ul> <p>Note</p> <p>Don't use GitHub issues to ask for help: These are reserved for proposed code changes only.</p>"},{"location":"development/#governance","title":"Governance","text":"<p>pynetbox follows the benevolent dictator model of governance, with the lead maintainer ultimately responsible for all changes to the code base. While community contributions are welcomed and encouraged, the lead maintainer's primary role is to ensure the project's long-term maintainability and continued focus on its primary functions.</p>"},{"location":"development/#licensing","title":"Licensing","text":"<p>The entire pynetbox project is licensed as open source under the Apache 2.0 license. This is a very permissive license which allows unlimited redistribution of all code within the project. Note that all submissions to the project are subject to the same license. </p>"},{"location":"development/getting-started/","title":"Getting Started","text":"<p>This guide will help you get started with development on pynetbox. It covers setting up your development environment and running tests.</p>"},{"location":"development/getting-started/#development-environment","title":"Development Environment","text":"<ol> <li>Fork the pynetbox repository on GitHub</li> <li>Clone your fork locally</li> <li>Create a virtual environment and install development dependencies:</li> </ol> <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows: venv\\Scripts\\activate\npip install -e \".[dev]\"\n</code></pre>"},{"location":"development/getting-started/#running-tests","title":"Running Tests","text":"<p>pynetbox uses pytest for testing. The test suite includes both unit tests and integration tests.</p>"},{"location":"development/getting-started/#unit-tests","title":"Unit Tests","text":"<p>To run the unit tests:</p> <pre><code>pytest tests/unit\n</code></pre>"},{"location":"development/getting-started/#integration-tests","title":"Integration Tests","text":"<p>The integration tests require a running NetBox instance. The test suite uses pytest-docker to spin up NetBox instances in Docker containers.</p> <p>To run the integration tests:</p> <pre><code>pytest tests/integration\n</code></pre> <p>You can specify which versions of NetBox to test against using the <code>--netbox-versions</code> flag:</p> <pre><code>pytest tests/integration --netbox-versions 4.2 4.3 4.4\n</code></pre>"},{"location":"development/getting-started/#running-specific-tests","title":"Running Specific Tests","text":"<p>You can run specific test files or test functions:</p> <pre><code># Run a specific test file\npytest tests/unit/test_api.py\n\n# Run a specific test function\npytest tests/unit/test_api.py::test_api_status\n\n# Run tests matching a pattern\npytest -k \"test_api\"\n</code></pre>"},{"location":"development/getting-started/#test-coverage","title":"Test Coverage","text":"<p>To run tests with coverage reporting:</p> <pre><code>pytest --cov=pynetbox tests/\n</code></pre>"},{"location":"development/getting-started/#submitting-pull-requests","title":"Submitting Pull Requests","text":"<p>Once you're happy with your work and have verified that all tests pass, commit your changes and push it upstream to your fork. Always provide descriptive (but not excessively verbose) commit messages. Be sure to prefix your commit message with the word \"Fixes\" or \"Closes\" and the relevant issue number (with a hash mark). This tells GitHub to automatically close the referenced issue once the commit has been merged.</p> <pre><code>git commit -m \"Closes #1234: Add IPv5 support\"\ngit push origin\n</code></pre> <p>Once your fork has the new commit, submit a pull request to the pynetbox repo to propose the changes. Be sure to provide a detailed accounting of the changes being made and the reasons for doing so.</p> <p>Once submitted, a maintainer will review your pull request and either merge it or request changes. If changes are needed, you can make them via new commits to your fork: The pull request will update automatically.</p> <p>Warning</p> <p>Remember, pull requests are permitted only for accepted issues. If an issue you want to work on hasn't been approved by a maintainer yet, it's best to avoid risking your time and effort on a change that might not be accepted. (The one exception to this is trivial changes to the documentation or other non-critical resources.) </p>"},{"location":"development/release-checklist/","title":"Release Checklist","text":"<p>This document outlines the steps required to prepare and publish a new release of pynetbox.</p>"},{"location":"development/release-checklist/#pre-release-tasks","title":"Pre-Release Tasks","text":"<ol> <li> <p>Ensure all tests are passing:    <pre><code>pytest\n</code></pre></p> </li> <li> <p>Update version number in <code>pynetbox/__init__.py</code></p> </li> <li>Update documentation for any new features or changes</li> <li>Check NetBox Docker releases:<ul> <li>Visit https://github.com/netbox-community/netbox-docker/releases</li> <li>Review the latest NetBox Docker releases and their corresponding NetBox versions</li> <li>Update supported NetBox versions in <code>tests/integration/conftest.py</code> if needed</li> <li>Ensure the <code>get_netbox_docker_version_tag</code> function in <code>tests/integration/conftest.py</code> is updated with any new version mappings</li> </ul> </li> </ol>"},{"location":"development/release-checklist/#release-tasks","title":"Release Tasks","text":"<ol> <li> <p>Create a new release branch from <code>master</code>:    <pre><code>git checkout master\ngit pull\ngit checkout -b release/vX.Y.Z\n</code></pre></p> </li> <li> <p>Commit version and changelog updates:    <pre><code>git commit -m \"Prepare release vX.Y.Z\"\n</code></pre></p> </li> <li> <p>Create a pull request to merge the release branch into <code>master</code></p> </li> <li> <p>Once merged, use github to create a new release:</p> <ol> <li>Go to the GitHub repository</li> <li>Click \"Releases\" in the right sidebar</li> <li>Click \"Create a new release\"</li> <li>Create a new tag (e.g., vX.Y.Z)</li> <li>Use the changelog content as the release description</li> <li>Publish the release</li> </ol> <p>The GitHub release will automatically trigger the workflow to publish to PyPI.</p> </li> </ol>"},{"location":"development/release-checklist/#supported-netbox-versions","title":"Supported NetBox Versions","text":"<p>pynetbox aims to support the current and previous two minor versions of NetBox. The supported versions are defined in <code>tests/integration/conftest.py</code> and should be updated as part of the release process. </p>"}]}